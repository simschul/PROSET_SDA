.SDA.lmdi <- function(year0, year1, 
                      zero.handling = FALSE, aggregate = TRUE) {
  # year0 <- io_table$year0[c("S", "L", "Y")]
  # year1 <- io_table$year1[c("S", "L", "Y")]
  # zero.handling <- FALSE
  # aggregate <- TRUE
  
  time <- list()
  time[[1]] <- system.time({
    n.comp <- length(year0)
    indices <- get_indices(year0)
    vars <- lapply(indices, function(x) 1:x) %>% 
      expand.grid
    decomp <- create_named_list(names(year0)) %>%
      lapply(., function(x) array(dim = indices))
    
  })
  time[[2]] <- system.time({
    #cl <- makeCluster(detectCores() - 1)
    #clusterExport(cl, c("vars", "extract_selected", "year0", "year1", "log_mean", "decomp"))
    pbmclapply(mc.cores = 7,  1:nrow(vars), FUN = function(j) {
      
      inds <- vars[j,] %>% as.numeric # combinations of coefficients
      y0 <- extract_selected(year0, inds) %>% prod
      y1 <- extract_selected(year1, inds) %>% prod
      
      if(zero.handling & (y0 == 0 | y1 == 0)) {
        # zero-value handling (as suggested in Wood & Lenzen 2006)
        # TODO: check again if it really does what it is supposed to
        if(y0 == 0 & y1 == 0) {
          res <- 0
        } else if (y0 == 0) {
          for(i in 1:n.comp) {
            x0 <- year0[[i]][inds[i], inds[i+1]]
            if(x0 == 0) {
              res <- y1
            } else {
              res <- 0
            }
            decomp[[i]][matrix(inds, ncol = length(inds))] <- res
          }
        } else if (y1 == 0) {
          for(i in 1:n.comp) {
            x1 <- year1[[i]][inds[i], inds[i+1]]
            if(x1 == 0) {
              res <- -y0
            } else {
              res <- 0
            }
            decomp[[i]][matrix(inds, ncol = length(inds))] <- res
          }
        }
        
      } else {
        # neither y0, y1, x0, x1 are zero OR zero.handling == FALSE
        y_log_mean <- log_mean(x = y1, 
                               y = y0)
        for(i in 1:n.comp) {
          x_log <- log(year1[[i]][inds[i], inds[i+1]] / year0[[i]][inds[i], inds[i+1]])
          decomp[[i]][matrix(inds, ncol = length(inds))] <- y_log_mean * x_log
        }  
      }  
    })
    #for(j in 1:nrow(vars)) {
    
    #}
    
  })
  time[[3]] <- system.time({
    if(aggregate) {
      decomp <- lapply(1:n.comp, function(x) {
        decomp[[x]] %>% apply(., c(x, x+1), sum)
      }) %>% setNames(names(year0))
    }  
  })
  return(decomp)
}

x1 <- c(io_table$year0[c("S", "L")], cbind(io_table$year0$Y, c(5,3,1,0)) %>% decompose_final_demand)
x2 <- c(io_table$year1[c("S", "L")], cbind(io_table$year1$Y, c(6,3,4,2)) %>% decompose_final_demand)

n_ind <- 100
n_em <- 1
n_fd <- 1
x1 <- list("S" = matrix(runif(n_ind*n_em), n_em, n_ind), 
           "L" = matrix(runif(n_ind^2), n_ind, n_ind), 
           "Y" = matrix(runif(n_ind * n_fd), n_ind, n_fd))

x0 <- create_random_IOtable(n_ind, n_em, n_fd)
x1 <- create_random_IOtable(n_ind, n_em, n_fd)

.SDA.lmdi(x0, x1)
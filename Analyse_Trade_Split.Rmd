---
title: "Investigating the Trade split assumption of MRIOs"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: console
---

```{r include=FALSE}
source("./settings.R")
source("./functions.R")
```



# Background
Whats the trade split assumption? 
Problem: Trade data bases (mainly comtrade, are there others?) does report on 
the destinations of 
imported product, i.e. the industrial sector where the import goes to. So we 
know how much (expressed in monetary units) steel Germany imports and where
(which country) this steel comes from. However, we do not know where the steel
used in the German car manufacturing really comes from. 
Therefore, most (if not all?) MRIO tables make the assumption that the import
shares of one product in one country are the same for ALL industries using that
product. 

# Check EXIOBASE3 for that assumption

Lets start by first loading the most recent version of EXIOBASE (3.6). It's 
comes as a product by product IO table in current prices. 
```{r}
ipath <- file.path(path2exiobase, "V3.6")
iyear <- 2011
Z <- fread(file.path(ipath, paste0("IOT_", iyear, "_pxp"), "Z.txt")) %>% 
  as.matrix
dim(Z)
Za <- array(Z, dim = c(200,49,200, 49))
Za[123,6,159,31] == Z[1123,6159]


```



We now select the products of the sector "Basic iron and steel and of ferro-alloys and first products thereof" which has the index 104 (out of 200 products). 


```{r}
EB3_metadata$pxp200[grepl("Motor", product200_name)]
isector <- 3
#iprod <- seq(29, 9800, by = 200)
iprod <- matrix(rep(seq(isector, 9800, by = 200), 49), ncol = 49)
diag(iprod) <- NA
dim(iprod)

#isector <- 1123
```

Now we calculate the trade shares of products of that category and plot: 
```{r}
imp_shares <- array(dim = c(200,49,200,49), 
                    dimnames = list(EB3_metadata$pxp200$product200_name,
                                    EB3_metadata$regions$country_code2, 
                                    EB3_metadata$pxp200$product200_name,
                                    EB3_metadata$regions$country_code2)) 
for (i in 1:dim(imp_shares)[1]) {
  for (j in 1:dim(imp_shares)[4]) {
    z <- Za[i,,,j]
    z[j,] <- 0
    z <- apply(z, 2, function(x) x / sum(x, na.rm = TRUE)) 
    imp_shares[i,,,j] <- z  
  }
}

colsums <- vector("numeric", 200)
for(i in 1:200) colsums[i] <- imp_shares[i,,,6] %>% apply(., 1, sd, na.rm = TRUE) 
which(colsums == max(colsums, na.rm = T))
imp_shares[13,,,6] %>% barplot(col = viridis(49), border = viridis(49), 
                               las = 2, cex.names = 0.4)


######

```

With the IO pxp tables the import shares are not present any more. So lets have a look at the SUTs. 

# SUTs

Load the tables: 
```{r}
path2sut <- file.path(path2exiobase, "MRSUT_2011")
sut <- readRDS(file.path(path2sut, "SUT.RData"))
```


```{r}
dim(sut$U) # product X industry (which products are used in which industries?)
U <- array(sut$U, dim = c(200,49,163,49), 
           dimnames = list(EB3_metadata$pxp200$product200_code, 
                           EB3_metadata$regions$country_code2,
                           EB3_metadata$pxp163$product163_code, 
                           EB3_metadata$regions$country_code2))

imp_shares <- array(dim = c(200,49,163,49), 
                    dimnames = list(EB3_metadata$pxp200$product200_name,
                                    EB3_metadata$regions$country_code2, 
                                    EB3_metadata$pxp200$product163_name,
                                    EB3_metadata$regions$country_code2))
i <- j <- 6
for (i in 1:dim(imp_shares)[1]) {
  for (j in 1:dim(imp_shares)[4]) {
    z <- U[i,,,j]
    z[j,] <- 0
    z <- apply(z, 2, function(x) x / sum(x, na.rm = TRUE)) 
    imp_shares[i,,,j] <- z  
  }
  cat(i, "")
}
imp_shares[is.nan(imp_shares)] <- NA
#imp_shares <- round(imp_shares, 4)

colsums <- vector("numeric", 200)
i <- 197
for(i in 1:200) colsums[i] <- imp_shares[i,,,6] %>% apply(., 1, zero_range) %>% zero_range
which(colsums == min(colsums, na.rm = T))

data <- imp_shares[3,,,6][,!is.na(imp_shares[3,,,6]) %>% colSums]
data %>% apply(., 1, zero_range, tol = 1E-4) %>% zero_range

barplot(data, col = viridis(49), border = viridis(49), las = 2, cex.names = 0.4)

```





# What can be done about it?

```{r}
shares <- Tmat[, ids_GER] %>% rowMeans
```


```{r}
dt_origin <- data.table("origin" = c("A", "B", "C", "D"), 
                        "value" = c(3,2,4,1))
dt_dest <- data.table("dest" = c("a", "b", "c", "d"), 
                      "value" = c(2,4,1,3))
dt_origin[, "prop" := value / sum(value)]

flows <- data.table("origin" = rep(dt_origin$origin, each = 4), 
                    "dest" = rep(dt_dest$dest, 4))
flows <- merge(flows, dt_origin, by = "origin")
flows <- merge(flows, dt_dest, by = "dest", suffixes = c(".origin", ".dest"))
setcolorder(flows, c("origin", "dest"))
flows[, "value.flow" := prop * value.dest]
flows[, mean(value.dest), by = dest]


```



```{r}
library(gtools)
# origin
a <- 3.5
b <- 0.01
#b <- 2.1
c <- 6.49
n_origin <- 3
origin_vec <- c(a, b, c) 
names(origin_vec) <- c("a", "b", "c")
# destination
A <- 1.3
A <- 0.01
B <- 4.89
C <- 2.7
D <- 2.4
n_dest <- 4
dest_vec <- c(A, B, C, D)
dest <- data.table("group" = LETTERS[1:4],
                   "value" = c(A, B, C, D))
dest[, "cumsum" := cumsum(value)]


N <- 50
n_iter <- 100
set.seed(123)
i <- 1
list <- create_named_list(1:n_iter)

for(i in 1:n_iter) {
  # system.time(
  # data <- data.table(origin = c(rep("a", N+1), rep("b", N+1), rep("c", N+1)),
  #                    value = c(runif(N, min = 0, max = a) %>% sort %>%
  #                                c(0,.,a) %>% diff,
  #                              runif(N, min = 0, max = b) %>% sort %>%
  #                                c(0,.,b) %>% diff,
  #                              runif(N, min = 0, max = c) %>% sort %>%
  #                                c(0,.,c) %>% diff))
  # )
  
  # split each import flow into N random sized bins  
  data <- lapply(origin_vec, function(x) {
    runif(N, min = 0, max = x) %>%
      sort %>%
      c(0,.,x) %>%
      diff %>%
      as.data.table %>%
      setnames("value")
  }) %>% setNames(names(origin_vec)) %>%
    rbindlist(idcol = "origin")
  
  # assign random numbers to each bin 
  data[, "bin" := sample((1:(3*N + 3)), replace = FALSE)]
  setorder(data, bin)
  data[, "cumsum" := cumsum(value)]
  
  # split those flows directly at the border between two destinations
  for(j in unique(dest$group)) {
    if (!(dest[group == j]$cumsum %in% data$cumsum)) {
      temp <- dest[group == j]$cumsum
      irow <- data[cumsum < temp] %>% nrow
      ibin <- c(0,data[cumsum < temp]$bin) %>% max 
      newbin <- data.table(origin = data[irow + 1,]$origin, 
                           value = dest[group == j]$cumsum - 
                             ifelse(length(data[bin == ibin]$cumsum) == 0, 
                                    0, data[bin == ibin]$cumsum), 
                           bin = ibin + 0.001, 
                           cumsum = dest[group == j]$cumsum)
      data[bin == ibin+1, value := value - newbin$value]
      data <- rbind(data, newbin) %>% 
        setorder(bin)    
    }
  }
  
  data[, "dest" := ""]
  for (j in rev(unique(dest$group))) {
    temp <- dest[group == j]$cumsum
    data[cumsum <= temp, dest := j]
  }
  data_agg <- data[, sum(value), by = .(origin, dest)] %>% 
    setnames("V1", "value")
  rm(data)
  gc()
  data_agg[, "prop" := value / sum(value), by = dest]
  list[[i]] <- data_agg
  cat(i, "")
}

lapply(list, function(x) x[, sum(value)])
```

# function 
ll that into a function: 
```{r}
randomize_flows <- function(origin_vec, dest, N, n_iter) {
  # N <- 50
  # n_iter <- 500
  # set.seed(123)
  
  # i <- 1
  # origin_vec <- orig
  origin_vec <- origin_vec[origin_vec != 0]
  # dest <- dest_dt
  origin_sum <- sum(origin_vec)
  dest_sum <- sum(dest$value)
  if (origin_sum != dest_sum) stop("origin does not equal destination flows")
  list <- create_named_list(1:n_iter)
  
  length_out <- min(origin_vec) / nrow(dest)
  for(i in 1:n_iter) {
    
    # split each import flow into N random sized bins  
    data <- lapply(origin_vec, function(x) {
      runif(x/length_out, min = 0, max = x) %>%
        sort %>%
        c(0,.,x) %>%
        diff %>%
        as.data.table %>%
        setnames("value")
    }) %>% setNames(names(origin_vec)) %>%
      rbindlist(idcol = "origin")
    data[, sum(value)] == origin_sum
    
    # assign random numbers to each bin 
    data[, "bin" := sample((1:.N), replace = FALSE)]
    setorder(data, bin)
    data[, "cumsum" := cumsum(value)]
    
    data[.N]$cumsum == origin_sum
    # split those flows directly at the border between two destinations
    for(j in unique(dest$group)) {
      if (!(dest[group == j]$cumsum %in% data$cumsum)) {
        temp <- dest[group == j]$cumsum
        irow <- data[cumsum < temp] %>% nrow
        ibin <- c(0,data[cumsum < temp]$bin) %>% max 
        newbin <- data.table(origin = data[irow + 1,]$origin, 
                             value = dest[group == j]$cumsum - 
                               ifelse(length(data[bin == ibin]$cumsum) == 0, 
                                      0, data[bin == ibin]$cumsum), 
                             bin = ibin + 0.001, 
                             cumsum = dest[group == j]$cumsum)
        data[irow + 1, value := value - newbin$value]
        data <- rbind(data, newbin) %>% 
          setorder(bin)    
      }
    }
    data[, sum(value)] == origin_sum
    
    data[, "dest" := ""]
    for (j in rev(unique(dest$group))) {
      temp <- dest[group == j]$cumsum
      data[cumsum <= temp, dest := j]
    }
    data_agg <- data[, sum(value), by = .(origin, dest)] %>% 
      setnames("V1", "value")
    
    
    rm(data)
    gc()
    data_agg[, "prop" := value / sum(value), by = dest]
    list[[i]] <- data_agg
    cat(i, "")
  }
  return(list)
}
test <- randomize_flows(origin_vec, dest = dest, n_iter = 100, 
                        N = 50)
lapply(test, function(x) x[, sum(prop)])
lapply(test, function(x) x[, sum(value)])

```


```{r}
# begin test
data_agg
U[3,,,6] %>% dim # input
iuse <- U[3,,,6][,colSums(U[3,,,6]) != 0]
iuse[6,] <- 0
index <- 6
x <- U[6,,,6]

randomize_U <- function(x, index) {
  # extract non zero flows
  if (sum(x[-index,]) > 0) {
    xnew <- x[, colSums(x) != 0]
    xnew[index,] <- 0
    # prepare data
    origin_vec <- xnew %>% rowSums
    dest_vec <- xnew %>% colSums()
    dest_vec <- dest_vec[dest_vec > 0]
    dest_dt <- data.table(group = names(dest_vec), 
                          value = dest_vec)
    dest_dt[, "cumsum" := cumsum(value)]
    origin_vec <- origin_vec[origin_vec != 0]
    origin_sum <- sum(origin_vec, na.rm = TRUE)
    dest_sum <- sum(dest_dt$value, na.rm = TRUE)
    if (!all.equal(origin_sum, dest_sum)) stop("origin does not equal 
                                       destination flows")
    length_out <- min(origin_vec) / nrow(dest_dt) # min. number of flows to sample
    data <- lapply(origin_vec, function(x) {
      runif(x/length_out, min = 0, max = x) %>%
        sort %>%
        c(0,.,x) %>%
        diff %>%
        as.data.table %>%
        setnames("value")
    }) %>% setNames(names(origin_vec)) %>%
      rbindlist(idcol = "origin")
    gc()
    #data[, sum(value)] == origin_sum
    
    # assign random numbers to each bin 
    data[, "bin" := sample((1:.N), replace = FALSE)]
    setorder(data, bin)
    data[, "cumsum" := cumsum(value)]
    data[, bin := NULL]
    gc()
    # begin test
    data
    j <- 106
    new_data <- create_named_list(dest_dt$group)
    data_between <- new_data
    for (j in 1:nrow(dest_dt)) {
      #irow <- data[cumsum < 0.01] %>% nrow
      irow <- data[cumsum < dest_dt$cumsum[j]] %>% nrow 
      if (irow == 0) {
        temp <- copy(data[1,])
        temp[, value := dest_dt$value[j]]
        temp[, "cumsum" := cumsum(value)]
        new_data[[j]] <- temp 
        data[1, value := value - temp$value]
      } else {
        new_data[[j]] <- data[1:irow, 
                              .(value = sum(value)), by = .(origin)] %>% 
          .[, "cumsum" := cumsum(value)]  
        if (irow < nrow(data)) {
          data_between[[j]] <- data[irow + 1, -"bin"]
          data <- data[(irow+2):.N]      
        }
      }
      
      gc()
      cat(j, "")
      if (j > 1) {
        temp1 <- dest_dt[j-1]$value - new_data[[j-1]]$value %>% sum
        temp2 <- data_between[[j-1]]$value - temp1
        if(temp1 < 0 | temp2 < 0) stop("bla")
        new_data[[j-1]] <- rbind(new_data[[j-1]],
                                 data_between[[j-1]][, value := temp1])
        new_data[[j]] <- rbind(data_between[[j-1]][, value := temp2],
                               new_data[[j]])
      }
      
    }
    gc()
    
    dest_dt[group == "p90.5.f"]
    plot(sapply(new_data, function(x) sum(x$value)) -dest_vec)
    abline(h = 0, col = "red")
    j <- 5
    for (j in 1:(length(data_between)-1)) {
      temp1 <- dest_dt[j]$value - new_data[[j]]$value %>% sum
      temp2 <- data_between[[j]]$value - temp1
      if(temp1 < 0 | temp2 < 0) stop("bla")
      new_data[[j]] <- rbind(new_data[[j]], data_between[[j]][, value := temp1])
      new_data[[j+1]] <- rbind(data_between[[j]][, value := temp2], new_data[[j+1]])
    }
    
    # end test
    
    
    #data[.N]$cumsum == origin_sum
    # split those flows directly at the border between two destinations
    #data[, "dest" := ""]
    for(j in unique(dest_dt$group)) {
      if (!(dest_dt[group == j]$cumsum %in% data$cumsum)) {
        temp <- dest_dt[group == j]$cumsum
        irow <- data[cumsum < temp] %>% nrow
        if (irow < nrow(data)) {
          ibin <- c(0,data[cumsum < temp]$bin) %>% max 
          newbin <- data.table(origin = data[irow + 1,]$origin, 
                               value = dest_dt[group == j]$cumsum - 
                                 ifelse(length(data[bin == ibin]$cumsum) == 0, 
                                        0, data[bin == ibin]$cumsum), 
                               bin = ibin + 0.001, 
                               cumsum = dest_dt[group == j]$cumsum)
          data[irow + 1, value := value - newbin$value]  
          #data[1:(irow+1)][dest == ""]$dest <- j
          data <- rbind(data, newbin) %>% 
            setorder(bin)
        }
      }
      #cat(j, "")
    }
    #data[, sum(value)] == origin_sum
    
    data[, "dest" := ""]
    for (j in rev(unique(dest_dt$group))) {
      temp <- dest_dt[group == j]$cumsum
      data[cumsum <= temp, dest := j]
    }
    data <- data[, sum(value), by = .(origin, dest)] %>% 
      setnames("V1", "value")
    
    # data <- dcast(data, origin ~ dest)
    # data[is.na(data)] <- 0
    # mat <- data[,-1] %>% as.matrix
    # colnames(mat) <- colnames(data)[-1]
    # rownames(mat) <- data[,1] %>% unlist
    
    x_dt <- x %>% as.data.table(keep.rownames = TRUE) %>% 
      melt %>% setnames(c("origin", "dest", "value"))
    #all.equal(x_dt[origin != "DEU", sum(value)], origin_sum)
    data <- merge(x_dt, data, 
                  by = c("origin", "dest"), 
                  all.x = TRUE, sort = FALSE)
    #data_agg2[is.na(value.y) & value.x != 0]
    
    data[origin == rownames(x)[index], value.y := value.x]
    data[is.na(value.y), value.y := 0]
    # all.equal(data[origin != "DEU", sum(value.y)],origin_sum)
    # all.equal(data[, sum(value)], origin_sum)
    
    new_mat <- data$value.y %>% 
      matrix(nrow = nrow(x), ncol = ncol(x))
    rm(data)
    gc()
    colnames(new_mat) <- colnames(x)
    rownames(new_mat) <- rownames(x)
    #all.equal(sum(new_mat), sum(x))
    return(new_mat)  
  } else {
    return(x)
  }
  
}

# run in a loop: 
new_U <- array(0, dim = dim(U))
system.time({
  for(i in 1:200) {
    x <- U[i,,,6]
    new_U[i,,,6] <- randomize_U(x, index = 6)
    cat(i, "")
  }  
})




sum(test)
new_mat <- test

diff <- new_mat - x

IOvisualize(diff)
reldiff <- (new_mat - x) / new_mat
reldiff[is.nan(reldiff)] <- NA
IOvisualize(reldiff)
x["CYP", "p05"]

sum(new_mat)
```


```{r}
dt <- rbindlist(list, idcol = "n")
dt[, n := as.numeric(n)]
dt[, "flow" := paste0(origin, "->", dest)]

ggplot(dt) + 
  geom_density(aes(x = value, fill = flow), 
               alpha = 0.3)
ggplot(dt) + 
  geom_density(aes(x = prop, fill = dest), 
               alpha = 0.3) + 
  facet_wrap(~origin)

ggplot(dt) + 
  geom_boxplot(aes(x = dest, y = prop, fill = dest))+ 
  facet_wrap(~origin)


```



check results and plot
```{r}
data[, sum(value), by = dest]
data[, sum(value), by = group]
temp <- data[, sum(value), by = .(group, dest)] 
temp[, "prop" := V1 / sum(V1), by = dest]
temp[, prop := round(prop, 2)]



data[bin %% 1 == 0.5]
ggplot(data, aes(x = bin, y = cumsum)) + 
  geom_point(aes(color = group))
#geom_hline(aes(yintercept = data$cumsum, color = group)) + 
#geom_line(aes(color = dest)) 

```




# Real life example
```{r}
U
imp_shares
ishares <- imp_shares[3,,,6][,!is.na(imp_shares[3,,,6]) %>% colSums]
iuse <- U[3,,,6][,colSums(U[3,,,6]) != 0]
iuse[6,] <- 0

orig <- iuse %>% rowSums()
dest_vec <- iuse %>% colSums()
dest_dt <- data.table(group = names(dest_vec), 
                      value = dest_vec)
dest_dt[, "cumsum" := cumsum(value)]

test2 <- randomize_flows(origin_vec = orig, 
                         dest = dest_dt, 
                         N = 50, n_iter = 100)

lapply(test2, function(x) x[dest == "p92", sum(value)]) %>% 
  unlist %>% var
lapply(test2, function(x) x[origin == "SWE", sum(value)]) %>% 
  unlist %>% var


dt <- rbindlist(test2, idcol = "n")
dt[, n := as.numeric(n)]
dt[, "flow" := paste0(origin, "->", dest)]

# ggplot(dt) + 
#   geom_density(aes(x = value, fill = flow), 
# alpha = 0.3)
dt[dest == "p15.i" & origin == "FRA"]$prop %>% hist

ggplot(dt[dest == "p15.i"]) + 
  geom_boxplot(aes(x = origin, y = prop))

EB3_metadata$pxp200[grepl("vehicle", product200_name)]

ggplot(dt) + 
  geom_density(aes(x = value %>% log, fill = dest), 
               alpha = 0.3) + 
  facet_wrap(~origin, scales = "free")

ggplot(dt) + 
  geom_boxplot(aes(x = dest, y = prop, fill = dest))+ 
  facet_wrap(~origin, scales = "free")
```




# Alternative methods to randomly allocate flows

```{r}
library(truncnorm)
library(gtools)

product <- 104
country <- 6
dim(U)
# 200 products from 49 region used in 163 industries in 49 regions

create_random_import_shares <- function(U, product, country) {
  U_subset <- U[product,,,country]
  U_subset[country,] <- 0
  
  origin_vec <- U_subset %>% rowSums # imports by country of origin
  dest_vec <- U_subset %>% colSums # imports by sector of destination
  
  # create new matrix to store import shares
  new_imp_shares <- U_subset %>% replace(., values = 0)
  randomize_flows2 <- function(origin_vec, dest_vec) {
    originprop_vec <- origin_vec / sum(origin_vec)
    destprop_vec <- dest_vec / sum(dest_vec)
    flows_left <- origin_vec
    resid <- dest_vec %>% replace(., values = 0)
    #i <- 2
    for (i in 1:length(dest_vec)) {
      # draw random numbers
      rand <- rtruncnorm(length(origin_vec),
                         a = 0,
                         mean = originprop_vec, 
                         sd = originprop_vec / 2)
      rand[is.nan(rand)] <- 0
      rand <- rand/ sum(rand)
      new_orig <- rand * dest_vec[i]
      # check how much is left
      temp <- flows_left - new_orig
      # if not enough left, take what is left
      new_orig[temp < 0] <- flows_left[temp < 0]
      # redistribute the rest
      rest <- temp[temp < 0] %>% sum %>% abs
      resid[i] <- rest
      
      new_imp_shares[,i] <- new_orig
      # update what is left
      flows_left <- flows_left - new_orig
      cat(i, "")
    }
    return(resid)
  }
  rest <- randomize_flows2(origin_vec, dest_vec)
  sum(rest)
  resid_dest <- rest
  resid_orig <- (origin_vec - (new_imp_shares %>% rowSums()))
  sum(resid_dest)
  sum(resid_orig)
  
  new_imp_shares1 <- new_imp_shares
  new_imp_shares <- U_subset %>% replace(., values = 0)

  rest2 <- randomize_flows2(resid_orig, resid_dest)
  sum(rest2)
  new_imp_shares
}

sum(resid) # sum of what is left
new_imp_shares %>% colSums # imports allocated to sectors
new_imp_shares %>% rowSums # ...by exporting country

(dest_vec - (new_imp_shares %>% colSums())) %>% plot # flows left by importing sector
(origin_vec - (new_imp_shares %>% rowSums())) %>% summary # flows left by exporting country 

(dest_vec - (new_imp_shares %>% colSums())) %>% sum # sum of flows left by importing sector
(origin_vec - (new_imp_shares %>% rowSums())) %>% sum # sum of flows left by exporting country 

sum(resid) / sum(new_imp_shares) # what proportion is left?

# redistribute the rest





test <- originprop_vec[originprop_vec > 0] %>% 
  log 
test <- test + (abs(min(test)) * 1.1)

rdirichlet(10, test) %>%
  boxplot
points(originprop_vec, col = "red", pch = 16)
plot(originprop_vec)

sum(rand)
(rand * dest_vec[2]) %>% sum


```










play around with other distribution to get a uniform dist: 

```{r}
# begin test
set.seed(123)
test <- rdirichlet(1000, rep(1, n_dest))

hist(test[,3])


supply <- c(a,b,c)
use <- c(A, B, C, D)
test2 <- (diag(supply) %*% test)
test2 %>% colSums
(test2 %*% diag(use))
(test %*% diag(use)) %>% colSums()

data <- data.table(id = 1:(3*N + 3),
                   group = c(rep("a", N+1), rep("b", N+1), rep("c", N+1)),
                   value = c(rdirichlet(N, min = 0, max = a) %>% sort %>%
                               c(0,.,a) %>% diff,
                             runif(N, min = 0, max = b) %>% sort %>%
                               c(0,.,b) %>% diff,
                             runif(N, min = 0, max = c) %>% sort %>%
                               c(0,.,c) %>% diff))
# end test

```







.SDA.lmdi(x1, x2)
.SDA.lmdi <- function(year0, year1) {
n.comp <- length(year0)
indices <- get_indices(year0)
cat(indices)
vars <- lapply(indices, function(x) 1:x) %>%
expand.grid
decomp <- create_named_list(names(year0)) %>%
lapply(., function(x) array(dim = indices))
for(j in 1:nrow(vars)) {
inds <- vars[j,] %>% as.numeric # combinations of coefficients
y_log_mean <- log_mean(x = extract_selected(year1, inds) %>%
prod,
y = extract_selected(year0, inds) %>%
prod)
for(i in 1:n.comp) {
decomp[[i]][inds[1], inds[2], inds[3], inds[4]] <- y_log_mean *
log(year1[[i]][inds[i], inds[i+1]] / year0[[i]][inds[i], inds[i+1]])
}
}
decomp <- lapply(1:n.comp, function(x) {
decomp[[x]] %>% apply(., c(x, x+1), sum)
}) %>% setNames(names(year0))
return(decomp)
}
.SDA.lmdi(x1, x2)
get_indices(x1)
x1
x1
x1$total %*% x1$B_mat %*% x1$d_vec
x1$total * x1$B_mat %*% x1$d_vec
x1$B_mat %*% x1$d_vec
x1$total * (x1$B_mat %*% x1$d_vec)
x1$total * (x1$B_mat %*% x1$d_vec)
(x1$B_mat %*% x1$d_vec)
x1$total <- as.numeric(x1$total)
x2$total <- as.numeric(x2$total)
x1
.SDA.lmdi(x1, x2)
get_indices(x1)
x1$total * (x1$B_mat %*% x1$d_vec)
(x1$B_mat %*% x1$d_vec) * x1$total
x1$total * x1$B_mat %*% x1$d_vec
x1
x1$total <- NULL
x1$total <- 30
x1
x2$total
x2$total <- NULL
x2$total <- 45
x2
.SDA.lmdi(x1, x2)
x1$total <- matrix(x1$total)
x2$total <- matrix(x2$total)
.SDA.lmdi(x1, x2)
x1$total <- as.numeric(x1$total)
x2$total <- as.numeric(x2$total)
x1
.SDA.lmdi(x1, x2)
extract_selected()
extract_selected
get_indices(x1)
extract_selected(x1, get_indices(x1))
get_indices(x1)
extract_selected
x1$total <- matrix(x1$total)
x2$total <- matrix(x2$total)
extract_selected(x1, get_indices(x1))
.SDA.lmdi(x1, x2)
decomp
decomp <- create_named_list(names(year0)) %>%
lapply(., function(x) array(dim = indices))
year0
create_named_list(names(year0))
indices
indices <- get_indices(year0)
decomp <- create_named_list(names(year0)) %>%
lapply(., function(x) array(dim = indices))
decomp
decomp[indices]
decomp[indices]
.SDA.lmdi <- function(year0, year1) {
n.comp <- length(year0)
indices <- get_indices(year0)
cat(indices)
vars <- lapply(indices, function(x) 1:x) %>%
expand.grid
decomp <- create_named_list(names(year0)) %>%
lapply(., function(x) array(dim = indices))
for(j in 1:nrow(vars)) {
inds <- vars[j,] %>% as.numeric # combinations of coefficients
y_log_mean <- log_mean(x = extract_selected(year1, inds) %>%
prod,
y = extract_selected(year0, inds) %>%
prod)
for(i in 1:n.comp) {
decomp[[i]][inds] <- y_log_mean *
log(year1[[i]][inds[i], inds[i+1]] / year0[[i]][inds[i], inds[i+1]])
}
}
decomp <- lapply(1:n.comp, function(x) {
decomp[[x]] %>% apply(., c(x, x+1), sum)
}) %>% setNames(names(year0))
return(decomp)
}
.SDA.lmdi(x1, x2)
decomp
decomp %>% dim
decomp
dim
decomp %>% dim
dim(decomp)
a <- array(dim = c(1,4,4,1))
a
a %>% dim
a <- array(dim = c(2,4,4,3))
a[1,1,1,1]
a <- array(1:(2*4*4*3), dim = c(2,4,4,3))
a
a[1,1,1,1]
b <- c(2,3,4,1)
a[b]
b
a[2,3,4,1]
b <- matrix(c(2,3,4,1))
a[b]
a[b,]
a[b]
b <- matrix(c(2,3,4,1))
b
b <- matrix(c(2,3,4,1), byrow = TRUE)
b
b <- matrix(c(2,3,4,1), byrow = FALSE)
b
a[b]
b <- matrix(c(2,3,4,1), ncol = 4)
b
a[b]
a[2,3,4,1]
for(j in 1:nrow(vars)) {
inds <- vars[j,] #%>% as.numeric # combinations of coefficients
y_log_mean <- log_mean(x = extract_selected(year1, inds) %>%
prod,
y = extract_selected(year0, inds) %>%
prod)
for(i in 1:n.comp) {
decomp[[i]][inds] <- y_log_mean *
log(year1[[i]][inds[i], inds[i+1]] / year0[[i]][inds[i], inds[i+1]])
}
}
.SDA.lmdi <- function(year0, year1) {
n.comp <- length(year0)
indices <- get_indices(year0)
cat(indices)
vars <- lapply(indices, function(x) 1:x) %>%
expand.grid
decomp <- create_named_list(names(year0)) %>%
lapply(., function(x) array(dim = indices))
for(j in 1:nrow(vars)) {
inds <- vars[j,] #%>% as.numeric # combinations of coefficients
y_log_mean <- log_mean(x = extract_selected(year1, inds) %>%
prod,
y = extract_selected(year0, inds) %>%
prod)
for(i in 1:n.comp) {
decomp[[i]][inds] <- y_log_mean *
log(year1[[i]][inds[i], inds[i+1]] / year0[[i]][inds[i], inds[i+1]])
}
}
decomp <- lapply(1:n.comp, function(x) {
decomp[[x]] %>% apply(., c(x, x+1), sum)
}) %>% setNames(names(year0))
return(decomp)
}
.SDA.lmdi(x1, x2)
.SDA.lmdi(year0, year1)
.SDA.lmdi <- function(year0, year1) {
n.comp <- length(year0)
indices <- get_indices(year0)
cat(indices)
vars <- lapply(indices, function(x) 1:x) %>%
expand.grid
decomp <- create_named_list(names(year0)) %>%
lapply(., function(x) array(dim = indices))
for(j in 1:nrow(vars)) {
inds <- vars[j,] #%>% as.numeric # combinations of coefficients
y_log_mean <- log_mean(x = extract_selected(year1, as.numeric(inds)) %>%
prod,
y = extract_selected(year0, as.numeric(inds)) %>%
prod)
for(i in 1:n.comp) {
decomp[[i]][inds] <- y_log_mean *
log(year1[[i]][inds[i], inds[i+1]] / year0[[i]][inds[i], inds[i+1]])
}
}
decomp <- lapply(1:n.comp, function(x) {
decomp[[x]] %>% apply(., c(x, x+1), sum)
}) %>% setNames(names(year0))
return(decomp)
}
.SDA.lmdi(x1, x2)
.SDA.lmdi(year0, year1)
.SDA.lmdi <- function(year0, year1) {
n.comp <- length(year0)
indices <- get_indices(year0)
cat(indices)
vars <- lapply(indices, function(x) 1:x) %>%
expand.grid
decomp <- create_named_list(names(year0)) %>%
lapply(., function(x) array(dim = indices))
for(j in 1:nrow(vars)) {
inds <- vars[j,] %>% as.numeric # combinations of coefficients
y_log_mean <- log_mean(x = extract_selected(year1, inds) %>%
prod,
y = extract_selected(year0, inds) %>%
prod)
for(i in 1:n.comp) {
decomp[[i]][matrix(inds, ncol = length(inds))] <- y_log_mean *
log(year1[[i]][inds[i], inds[i+1]] / year0[[i]][inds[i], inds[i+1]])
}
}
decomp <- lapply(1:n.comp, function(x) {
decomp[[x]] %>% apply(., c(x, x+1), sum)
}) %>% setNames(names(year0))
return(decomp)
}
.SDA.lmdi(x1, x2)
delta <- lapply(1:length(x1), function(x) {
return(x2[[x]] - x1[[x]])
})
delta
.SDA.lmdi(x1, x2)
x1
x2
extract_selected
year0
inds
# begin test
year0 <- io_table$year0[c("S", "L", "Y")]
year1 <- io_table$year1[c("S", "L", "Y")]
n.comp <- length(year0)
# calculate difference for each argument between year 0 and year 1
delta <- lapply(1:n.comp, function(x) {
return(year1[[x]] - year0[[x]])
})
n.comp <- length(year0)
indices <- get_indices(year0)
vars <- lapply(indices, function(x) 1:x) %>%
expand.grid
decomp <- create_named_list(names(year0)) %>%
lapply(., function(x) array(dim = indices))
inds <- vars[j,] %>% as.numeric # combinations of coefficients
j <- 1
inds <- vars[j,] %>% as.numeric # combinations of coefficients
inds
y0 <- extract_selected(year0, inds)
y0
year0
y1 <- extract_selected(year1, inds)
y1
y0 <- extract_selected(year0, inds) %>% prod
y0
y1 <- extract_selected(year1, inds) %>% prod
y1
year0[[i]]
i <- 1
year0[[i]]
year0[[i]][inds[i], inds[i+1]]
inds
for(j in 1:nrow(vars)) {
inds <- vars[j,] %>% as.numeric # combinations of coefficients
y0 <- extract_selected(year0, inds) %>% prod
y1 <- extract_selected(year1, inds) %>% prod
# zero-value handling (as suggested in Wood & Lenzen 2006)
if(y0 == 0 & y1 == 0) {
res <- 0
} else if (y0 == 0) {
for(i in 1:n.comp) {
x0 <- year0[[i]][inds[i], inds[i+1]]
if(x0 == 0) {
res <- y1
} else {
res <- 0
}
decomp[[i]][matrix(inds, ncol = length(inds))] <- res
}
} else if (y1 == 0) {
for(i in 1:n.comp) {
x1 <- year1[[i]][inds[i], inds[i+1]]
if(x1 == 0) {
res <- -y0
} else {
res <- 0
}
decomp[[i]][matrix(inds, ncol = length(inds))] <- res
}
} else {
y_log_mean <- log_mean(x = y1,
y = y0)
for(i in 1:n.comp) {
x_log <- log(year1[[i]][inds[i], inds[i+1]] / year0[[i]][inds[i], inds[i+1]])
decomp[[i]][matrix(inds, ncol = length(inds))] <- y_log_mean * x_log
}
}
decomp <- lapply(1:n.comp, function(x) {
decomp[[x]] %>% apply(., c(x, x+1), sum)
}) %>% setNames(names(year0))
return(decomp)
}
.SDA.lmdi(year0, year1)
.SDA.lmdi(x1, x2)
for(j in 1:nrow(vars)) {
inds <- vars[j,] %>% as.numeric # combinations of coefficients
y0 <- extract_selected(year0, inds) %>% prod
y1 <- extract_selected(year1, inds) %>% prod
# zero-value handling (as suggested in Wood & Lenzen 2006)
if(y0 == 0 & y1 == 0) {
res <- 0
} else if (y0 == 0) {
for(i in 1:n.comp) {
x0 <- year0[[i]][inds[i], inds[i+1]]
if(x0 == 0) {
res <- y1
} else {
res <- 0
}
decomp[[i]][matrix(inds, ncol = length(inds))] <- res
}
} else if (y1 == 0) {
for(i in 1:n.comp) {
x1 <- year1[[i]][inds[i], inds[i+1]]
if(x1 == 0) {
res <- -y0
} else {
res <- 0
}
decomp[[i]][matrix(inds, ncol = length(inds))] <- res
}
} else {
y_log_mean <- log_mean(x = y1,
y = y0)
for(i in 1:n.comp) {
x_log <- log(year1[[i]][inds[i], inds[i+1]] / year0[[i]][inds[i], inds[i+1]])
decomp[[i]][matrix(inds, ncol = length(inds))] <- y_log_mean * x_log
}
}
decomp <- lapply(1:n.comp, function(x) {
decomp[[x]] %>% apply(., c(x, x+1), sum)
}) %>% setNames(names(year0))
return(decomp)
}
.SDA.lmdi <- function(year0, year1) {
n.comp <- length(year0)
indices <- get_indices(year0)
vars <- lapply(indices, function(x) 1:x) %>%
expand.grid
decomp <- create_named_list(names(year0)) %>%
lapply(., function(x) array(dim = indices))
for(j in 1:nrow(vars)) {
inds <- vars[j,] %>% as.numeric # combinations of coefficients
y0 <- extract_selected(year0, inds) %>% prod
y1 <- extract_selected(year1, inds) %>% prod
# zero-value handling (as suggested in Wood & Lenzen 2006)
if(y0 == 0 & y1 == 0) {
res <- 0
} else if (y0 == 0) {
for(i in 1:n.comp) {
x0 <- year0[[i]][inds[i], inds[i+1]]
if(x0 == 0) {
res <- y1
} else {
res <- 0
}
decomp[[i]][matrix(inds, ncol = length(inds))] <- res
}
} else if (y1 == 0) {
for(i in 1:n.comp) {
x1 <- year1[[i]][inds[i], inds[i+1]]
if(x1 == 0) {
res <- -y0
} else {
res <- 0
}
decomp[[i]][matrix(inds, ncol = length(inds))] <- res
}
} else {
y_log_mean <- log_mean(x = y1,
y = y0)
for(i in 1:n.comp) {
x_log <- log(year1[[i]][inds[i], inds[i+1]] / year0[[i]][inds[i], inds[i+1]])
decomp[[i]][matrix(inds, ncol = length(inds))] <- y_log_mean * x_log
}
}
}
decomp <- lapply(1:n.comp, function(x) {
decomp[[x]] %>% apply(., c(x, x+1), sum)
}) %>% setNames(names(year0))
return(decomp)
}
.SDA.lmdi(year0, year1)
.SDA.lmdi(x1, x2)
delta <- lapply(1:length(x1), function(x) {
return(x2[[x]] - x1[[x]])
})
delta
.SDA.lmdi <- function(year0, year1) {
n.comp <- length(year0)
indices <- get_indices(year0)
vars <- lapply(indices, function(x) 1:x) %>%
expand.grid
decomp <- create_named_list(names(year0)) %>%
lapply(., function(x) array(dim = indices))
for(j in 1:nrow(vars)) {
inds <- vars[j,] %>% as.numeric # combinations of coefficients
y0 <- extract_selected(year0, inds) %>% prod
y1 <- extract_selected(year1, inds) %>% prod
# zero-value handling (as suggested in Wood & Lenzen 2006)
if(y0 == 0 & y1 == 0) {
res <- 0
} else if (y0 == 0) {
for(i in 1:n.comp) {
x0 <- year0[[i]][inds[i], inds[i+1]]
if(x0 == 0) {
res <- y1
} else {
res <- 0
}
decomp[[i]][matrix(inds, ncol = length(inds))] <- res
}
} else if (y1 == 0) {
for(i in 1:n.comp) {
x1 <- year1[[i]][inds[i], inds[i+1]]
if(x1 == 0) {
res <- -y0
} else {
res <- 0
}
decomp[[i]][matrix(inds, ncol = length(inds))] <- res
}
} else {
# neither y0, y1, x0, x1 are zero
y_log_mean <- log_mean(x = y1,
y = y0)
for(i in 1:n.comp) {
x_log <- log(year1[[i]][inds[i], inds[i+1]] / year0[[i]][inds[i], inds[i+1]])
decomp[[i]][matrix(inds, ncol = length(inds))] <- y_log_mean * x_log
}
}
}
decomp <- lapply(1:n.comp, function(x) {
decomp[[x]] %>% apply(., c(x, x+1), sum)
}) %>% setNames(names(year0))
return(decomp)
}
x1
x1$L[2,2] <- 0
x1$L
.SDA.lmdi(x1, x2)
delta
x1
.SDA.lmdi <- function(year0, year1, zero.handling = FALSE) {
n.comp <- length(year0)
indices <- get_indices(year0)
vars <- lapply(indices, function(x) 1:x) %>%
expand.grid
decomp <- create_named_list(names(year0)) %>%
lapply(., function(x) array(dim = indices))
for(j in 1:nrow(vars)) {
inds <- vars[j,] %>% as.numeric # combinations of coefficients
y0 <- extract_selected(year0, inds) %>% prod
y1 <- extract_selected(year1, inds) %>% prod
if(zero.handling & (y0 == 0 | y1 == 0)) {
# zero-value handling (as suggested in Wood & Lenzen 2006)
if(y0 == 0 & y1 == 0) {
res <- 0
} else if (y0 == 0) {
for(i in 1:n.comp) {
x0 <- year0[[i]][inds[i], inds[i+1]]
if(x0 == 0) {
res <- y1
} else {
res <- 0
}
decomp[[i]][matrix(inds, ncol = length(inds))] <- res
}
} else if (y1 == 0) {
for(i in 1:n.comp) {
x1 <- year1[[i]][inds[i], inds[i+1]]
if(x1 == 0) {
res <- -y0
} else {
res <- 0
}
decomp[[i]][matrix(inds, ncol = length(inds))] <- res
}
}
} else {
# neither y0, y1, x0, x1 are zero
y_log_mean <- log_mean(x = y1,
y = y0)
for(i in 1:n.comp) {
x_log <- log(year1[[i]][inds[i], inds[i+1]] / year0[[i]][inds[i], inds[i+1]])
decomp[[i]][matrix(inds, ncol = length(inds))] <- y_log_mean * x_log
}
}
}
decomp <- lapply(1:n.comp, function(x) {
decomp[[x]] %>% apply(., c(x, x+1), sum)
}) %>% setNames(names(year0))
return(decomp)
}
.SDA.lmdi(x1, x2)

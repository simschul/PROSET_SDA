temp0[1:i] <- year0[1:i]
temp0[i:n] <- year1[i:n]
temp0[[i]] <- delta[[i]]
# the other way round
temp1[1:i] <- year1[1:i]
temp1[i:n] <- year0[i:n]
temp1[[i]] <- delta[[i]]
# take mean of the two
decomp[[i]] <- 0.5 * (fun(temp0) + fun(temp1))
}
} else if(type == "LMDI1") {
l <- log_mean(fun(year1), fun(year0))
print(l)
for(i in 1:n) {
y0 <- as.numeric(year0[[i]])
y1 <- as.numeric(year1[[i]])
dy <- y1 - y0
temp <- 0
for(j in 1:length(y0)){
temp <- temp + l * log(y1[j] / y0[j])
#temp <- temp +  (fun(year1) - fun(year0) /  log()) * log(y1[j] / y0[j])
}
decomp[[i]] <- temp
decomp[[i]] <- as.numeric(log_mean(fun(year1), fun(year0))) * (log(year1[[i]] / year0[[i]]))
}
}
return(decomp)
}
test2 <- sda_fun(x1, x2, emission_calculator, type = "LMDI1")
sda_fun <- function(year0, year1, fun, type = "AMDI") {
#if(type != "polar_average") stop("Only method 'polar average' implemented so far")
if(length(year0) != length(year1)) stop("Both lists need to be of same legnth")
if(!all.equal(names(year0), names(year1))) stop("both lists need same elements in same order")
n <- length(year0)
# calculate difference for each argument between year 0 and year 1
delta <- create_named_list(names(year0))
for(i in 1:n) {
delta[[i]] <- year1[[i]] - year0[[i]]
}
decomp <- create_named_list(names(year0))
if(type == "AMDI") {
temp0 <- create_named_list(names(year0))
temp1 <- create_named_list(names(year0))
for(i in 1:n) {
# all components on the left hand side from year 0, right: year 1
temp0[1:i] <- year0[1:i]
temp0[i:n] <- year1[i:n]
temp0[[i]] <- delta[[i]]
# the other way round
temp1[1:i] <- year1[1:i]
temp1[i:n] <- year0[i:n]
temp1[[i]] <- delta[[i]]
# take mean of the two
decomp[[i]] <- 0.5 * (fun(temp0) + fun(temp1))
}
} else if(type == "LMDI1") {
l <- log_mean(fun(year1), fun(year0))
print(paste("here" l))
for(i in 1:n) {
y0 <- as.numeric(year0[[i]])
y1 <- as.numeric(year1[[i]])
dy <- y1 - y0
temp <- 0
for(j in 1:length(y0)){
temp <- temp + l * log(y1[j] / y0[j])
#temp <- temp +  (fun(year1) - fun(year0) /  log()) * log(y1[j] / y0[j])
}
decomp[[i]] <- temp
decomp[[i]] <- as.numeric(log_mean(fun(year1), fun(year0))) * (log(year1[[i]] / year0[[i]]))
}
}
return(decomp)
}
sda_fun <- function(year0, year1, fun, type = "AMDI") {
#if(type != "polar_average") stop("Only method 'polar average' implemented so far")
if(length(year0) != length(year1)) stop("Both lists need to be of same legnth")
if(!all.equal(names(year0), names(year1))) stop("both lists need same elements in same order")
n <- length(year0)
# calculate difference for each argument between year 0 and year 1
delta <- create_named_list(names(year0))
for(i in 1:n) {
delta[[i]] <- year1[[i]] - year0[[i]]
}
decomp <- create_named_list(names(year0))
if(type == "AMDI") {
temp0 <- create_named_list(names(year0))
temp1 <- create_named_list(names(year0))
for(i in 1:n) {
# all components on the left hand side from year 0, right: year 1
temp0[1:i] <- year0[1:i]
temp0[i:n] <- year1[i:n]
temp0[[i]] <- delta[[i]]
# the other way round
temp1[1:i] <- year1[1:i]
temp1[i:n] <- year0[i:n]
temp1[[i]] <- delta[[i]]
# take mean of the two
decomp[[i]] <- 0.5 * (fun(temp0) + fun(temp1))
}
} else if(type == "LMDI1") {
l <- log_mean(fun(year1), fun(year0))
print(paste("here", l))
for(i in 1:n) {
y0 <- as.numeric(year0[[i]])
y1 <- as.numeric(year1[[i]])
dy <- y1 - y0
temp <- 0
for(j in 1:length(y0)){
temp <- temp + l * log(y1[j] / y0[j])
#temp <- temp +  (fun(year1) - fun(year0) /  log()) * log(y1[j] / y0[j])
}
decomp[[i]] <- temp
decomp[[i]] <- as.numeric(log_mean(fun(year1), fun(year0))) * (log(year1[[i]] / year0[[i]]))
}
}
return(decomp)
}
test2 <- sda_fun(x1, x2, emission_calculator, type = "LMDI1")
sda_fun <- function(year0, year1, fun, type = "AMDI") {
#if(type != "polar_average") stop("Only method 'polar average' implemented so far")
if(length(year0) != length(year1)) stop("Both lists need to be of same legnth")
if(!all.equal(names(year0), names(year1))) stop("both lists need same elements in same order")
n <- length(year0)
# calculate difference for each argument between year 0 and year 1
delta <- create_named_list(names(year0))
for(i in 1:n) {
delta[[i]] <- year1[[i]] - year0[[i]]
}
decomp <- create_named_list(names(year0))
if(type == "AMDI") {
temp0 <- create_named_list(names(year0))
temp1 <- create_named_list(names(year0))
for(i in 1:n) {
# all components on the left hand side from year 0, right: year 1
temp0[1:i] <- year0[1:i]
temp0[i:n] <- year1[i:n]
temp0[[i]] <- delta[[i]]
# the other way round
temp1[1:i] <- year1[1:i]
temp1[i:n] <- year0[i:n]
temp1[[i]] <- delta[[i]]
# take mean of the two
decomp[[i]] <- 0.5 * (fun(temp0) + fun(temp1))
}
} else if(type == "LMDI1") {
l <- log_mean(fun(year1), fun(year0))
print(l)
for(i in 1:n) {
y0 <- as.numeric(year0[[i]])
y1 <- as.numeric(year1[[i]])
dy <- y1 - y0
temp <- 0
for(j in 1:length(y0)){
temp <- temp + l * log(y1[j] / y0[j])
#temp <- temp +  (fun(year1) - fun(year0) /  log()) * log(y1[j] / y0[j])
}
decomp[[i]] <- temp
decomp[[i]] <- as.numeric(log_mean(fun(year1), fun(year0))) * (log(year1[[i]] / year0[[i]]))
}
}
return(decomp)
}
test2 <- sda_fun(x1, x2, emission_calculator, type = "LMDI1")
test2
b1 <- emission_calculator(x1) %>% sum
b1
b2 <- emission_calculator(x2) %>% sum
b2
log_mean(b1, b2)
sda_fun <- function(year0, year1, fun, type = "AMDI") {
#if(type != "polar_average") stop("Only method 'polar average' implemented so far")
if(length(year0) != length(year1)) stop("Both lists need to be of same legnth")
if(!all.equal(names(year0), names(year1))) stop("both lists need same elements in same order")
n <- length(year0)
# calculate difference for each argument between year 0 and year 1
delta <- create_named_list(names(year0))
for(i in 1:n) {
delta[[i]] <- year1[[i]] - year0[[i]]
}
decomp <- create_named_list(names(year0))
if(type == "AMDI") {
temp0 <- create_named_list(names(year0))
temp1 <- create_named_list(names(year0))
for(i in 1:n) {
# all components on the left hand side from year 0, right: year 1
temp0[1:i] <- year0[1:i]
temp0[i:n] <- year1[i:n]
temp0[[i]] <- delta[[i]]
# the other way round
temp1[1:i] <- year1[1:i]
temp1[i:n] <- year0[i:n]
temp1[[i]] <- delta[[i]]
# take mean of the two
decomp[[i]] <- 0.5 * (fun(temp0) + fun(temp1))
}
} else if(type == "LMDI1") {
l <- log_mean(fun(year1), fun(year0)) %>% as.numeric
print(l)
for(i in 1:n) {
y0 <- as.numeric(year0[[i]])
y1 <- as.numeric(year1[[i]])
dy <- y1 - y0
temp <- 0
for(j in 1:length(y0)){
temp <- temp + l * log(y1[j] / y0[j])
#temp <- temp +  (fun(year1) - fun(year0) /  log()) * log(y1[j] / y0[j])
}
decomp[[i]] <- temp
# decomp[[i]] <- as.numeric(log_mean(fun(year1), fun(year0))) * (log(year1[[i]] / year0[[i]]))
}
}
return(decomp)
}
test2 <- sda_fun(x1, x2, emission_calculator, type = "LMDI1")
test2
test <- sda_fun(x1, x2, emission_calculator)
test
lapply(test2, sum) %>% unlist %>% sum
sda_fun <- function(year0, year1, fun, type = "AMDI") {
#if(type != "polar_average") stop("Only method 'polar average' implemented so far")
if(length(year0) != length(year1)) stop("Both lists need to be of same legnth")
if(!all.equal(names(year0), names(year1))) stop("both lists need same elements in same order")
n <- length(year0)
# calculate difference for each argument between year 0 and year 1
delta <- create_named_list(names(year0))
for(i in 1:n) {
delta[[i]] <- year1[[i]] - year0[[i]]
}
decomp <- create_named_list(names(year0))
if(type == "AMDI") {
temp0 <- create_named_list(names(year0))
temp1 <- create_named_list(names(year0))
for(i in 1:n) {
# all components on the left hand side from year 0, right: year 1
temp0[1:i] <- year0[1:i]
temp0[i:n] <- year1[i:n]
temp0[[i]] <- delta[[i]]
# the other way round
temp1[1:i] <- year1[1:i]
temp1[i:n] <- year0[i:n]
temp1[[i]] <- delta[[i]]
# take mean of the two
decomp[[i]] <- 0.5 * (fun(temp0) + fun(temp1))
}
} else if(type == "LMDI1") {
l <- log_mean(fun(year1), fun(year0)) %>% as.numeric
print(l)
for(i in 1:n) {
y0 <- as.numeric(year0[[i]])
y1 <- as.numeric(year1[[i]])
dy <- y1 - y0
temp <- 0
for(j in 1:length(y0)){
temp <- temp + log(y1[j] / y0[j])
#temp <- temp +  (fun(year1) - fun(year0) /  log()) * log(y1[j] / y0[j])
}
decomp[[i]] <- temp * l
# decomp[[i]] <- as.numeric(log_mean(fun(year1), fun(year0))) * (log(year1[[i]] / year0[[i]]))
}
}
return(decomp)
}
test2 <- sda_fun(x1, x2, emission_calculator, type = "LMDI1")
test2
nrow(c(1:4))
x1
sda_fun <- function(year0, year1, fun, type = "AMDI") {
#if(type != "polar_average") stop("Only method 'polar average' implemented so far")
if(length(year0) != length(year1)) stop("Both lists need to be of same legnth")
if(!all.equal(names(year0), names(year1))) stop("both lists need same elements in same order")
n <- length(year0)
# calculate difference for each argument between year 0 and year 1
delta <- create_named_list(names(year0))
for(i in 1:n) {
delta[[i]] <- year1[[i]] - year0[[i]]
}
decomp <- create_named_list(names(year0))
if(type == "AMDI") {
temp0 <- create_named_list(names(year0))
temp1 <- create_named_list(names(year0))
for(i in 1:n) {
# all components on the left hand side from year 0, right: year 1
temp0[1:i] <- year0[1:i]
temp0[i:n] <- year1[i:n]
temp0[[i]] <- delta[[i]]
# the other way round
temp1[1:i] <- year1[1:i]
temp1[i:n] <- year0[i:n]
temp1[[i]] <- delta[[i]]
# take mean of the two
decomp[[i]] <- 0.5 * (fun(temp0) + fun(temp1))
}
} else if(type == "LMDI1") {
l <- log_mean(fun(year1), fun(year0)) %>% as.numeric
print(l)
# delta S
temp <- 0
for(m in 1:4) {
for(n in 1:4) {
temp <- temp + l[m,n] * log(year0[[1]][1,n])
}
}
decomp[[1]] <- temp
# delta L
temp <- 0
for(m in 1:4) {
for(n in 1:4) {
temp <- temp + l[m,n] * log(year0[[2]][m,n])
}
}
decomp[[2]] <- temp
# delta Y
temp <- 0
for(m in 1:4) {
for(n in 1:4) {
temp <- temp + l[m,n] * log(year0[[3]][m,1])
}
}
decomp[[3]] <- temp
#
# for(i in 1:n) {
#   y0 <- as.numeric(year0[[i]])
#   y1 <- as.numeric(year1[[i]])
#   dy <- y1 - y0
#   temp <- 0
#
#   for(j in 1:length(y0)){
#     temp <- temp + log(y1[j] / y0[j])
#     #temp <- temp +  (fun(year1) - fun(year0) /  log()) * log(y1[j] / y0[j])
#   }
#   decomp[[i]] <- temp * l
#
#   # decomp[[i]] <- as.numeric(log_mean(fun(year1), fun(year0))) * (log(year1[[i]] / year0[[i]]))
#
#   }
}
return(decomp)
}
test <- sda_fun(x1, x2, emission_calculator)
test
test2 <- sda_fun(x1, x2, emission_calculator, type = "LMDI1")
sda_fun <- function(year0, year1, fun, type = "AMDI") {
#if(type != "polar_average") stop("Only method 'polar average' implemented so far")
if(length(year0) != length(year1)) stop("Both lists need to be of same legnth")
if(!all.equal(names(year0), names(year1))) stop("both lists need same elements in same order")
n <- length(year0)
# calculate difference for each argument between year 0 and year 1
delta <- create_named_list(names(year0))
for(i in 1:n) {
delta[[i]] <- year1[[i]] - year0[[i]]
}
decomp <- create_named_list(names(year0))
if(type == "AMDI") {
temp0 <- create_named_list(names(year0))
temp1 <- create_named_list(names(year0))
for(i in 1:n) {
# all components on the left hand side from year 0, right: year 1
temp0[1:i] <- year0[1:i]
temp0[i:n] <- year1[i:n]
temp0[[i]] <- delta[[i]]
# the other way round
temp1[1:i] <- year1[1:i]
temp1[i:n] <- year0[i:n]
temp1[[i]] <- delta[[i]]
# take mean of the two
decomp[[i]] <- 0.5 * (fun(temp0) + fun(temp1))
}
} else if(type == "LMDI1") {
l <- log_mean(emission_calculator(year1, "detailed"), emission_calculator(year0, "detailed"))
print(l)
# delta S
temp <- 0
for(m in 1:4) {
for(n in 1:4) {
temp <- temp + l[m,n] * log(year0[[1]][1,n])
}
}
decomp[[1]] <- temp
# delta L
temp <- 0
for(m in 1:4) {
for(n in 1:4) {
temp <- temp + l[m,n] * log(year0[[2]][m,n])
}
}
decomp[[2]] <- temp
# delta Y
temp <- 0
for(m in 1:4) {
for(n in 1:4) {
temp <- temp + l[m,n] * log(year0[[3]][m,1])
}
}
decomp[[3]] <- temp
#
# for(i in 1:n) {
#   y0 <- as.numeric(year0[[i]])
#   y1 <- as.numeric(year1[[i]])
#   dy <- y1 - y0
#   temp <- 0
#
#   for(j in 1:length(y0)){
#     temp <- temp + log(y1[j] / y0[j])
#     #temp <- temp +  (fun(year1) - fun(year0) /  log()) * log(y1[j] / y0[j])
#   }
#   decomp[[i]] <- temp * l
#
#   # decomp[[i]] <- as.numeric(log_mean(fun(year1), fun(year0))) * (log(year1[[i]] / year0[[i]]))
#
#   }
}
return(decomp)
}
test2 <- sda_fun(x1, x2, emission_calculator, type = "LMDI1")
sda_fun <- function(year0, year1, fun, type = "AMDI") {
#if(type != "polar_average") stop("Only method 'polar average' implemented so far")
if(length(year0) != length(year1)) stop("Both lists need to be of same legnth")
if(!all.equal(names(year0), names(year1))) stop("both lists need same elements in same order")
n <- length(year0)
# calculate difference for each argument between year 0 and year 1
delta <- create_named_list(names(year0))
for(i in 1:n) {
delta[[i]] <- year1[[i]] - year0[[i]]
}
decomp <- create_named_list(names(year0))
if(type == "AMDI") {
temp0 <- create_named_list(names(year0))
temp1 <- create_named_list(names(year0))
for(i in 1:n) {
# all components on the left hand side from year 0, right: year 1
temp0[1:i] <- year0[1:i]
temp0[i:n] <- year1[i:n]
temp0[[i]] <- delta[[i]]
# the other way round
temp1[1:i] <- year1[1:i]
temp1[i:n] <- year0[i:n]
temp1[[i]] <- delta[[i]]
# take mean of the two
decomp[[i]] <- 0.5 * (fun(temp0) + fun(temp1))
}
} else if(type == "LMDI1") {
l <- log_mean(emission_calculator(year1, "detailed"), emission_calculator(year0, "detailed"))
print(l)
# delta S
temp <- 0
for(m in 1:4) {
for(n in 1:4) {
temp <- temp + l[1,n] * log(year0[[1]][1,n])
}
}
decomp[[1]] <- temp
# delta L
temp <- 0
for(m in 1:4) {
for(n in 1:4) {
temp <- temp + l[1,n] * log(year0[[2]][m,n])
}
}
decomp[[2]] <- temp
# delta Y
temp <- 0
for(m in 1:4) {
for(n in 1:4) {
temp <- temp + l[1,n] * log(year0[[3]][m,1])
}
}
decomp[[3]] <- temp
#
# for(i in 1:n) {
#   y0 <- as.numeric(year0[[i]])
#   y1 <- as.numeric(year1[[i]])
#   dy <- y1 - y0
#   temp <- 0
#
#   for(j in 1:length(y0)){
#     temp <- temp + log(y1[j] / y0[j])
#     #temp <- temp +  (fun(year1) - fun(year0) /  log()) * log(y1[j] / y0[j])
#   }
#   decomp[[i]] <- temp * l
#
#   # decomp[[i]] <- as.numeric(log_mean(fun(year1), fun(year0))) * (log(year1[[i]] / year0[[i]]))
#
#   }
}
return(decomp)
}
test2 <- sda_fun(x1, x2, emission_calculator, type = "LMDI1")
as.matrix(x1$Y)
as.matrix(x1$Y, nrow = 1)
as.matrix(x1$Y, byrow = TRUE)
as.matrix(x1$Y, ncol = 4, nrow = 1)
x1$Y
matrix(x1$Y, ncol = 4, nrow = 1)
x1$Y <- matrix(x1$Y, ncol = 4, nrow = 1)
x2$Y <- matrix(x2$Y, ncol = 4, nrow = 1)
test2 <- sda_fun(x1, x2, emission_calculator, type = "LMDI1")
test2 <- sda_fun(x1, x2, emission_calculator, type = "LMDI1")
emission_calculator <- function(list, return = c("total", "detailed")) {
if(is.matrix(list[[3]])) list[[3]] <- as.numeric(list[[3]])
x <- as.numeric(list[[2]] %*% list[[3]])
if("total" %in% return) B <- list[[1]] %*% x
else if(return == "detailed") B <- list[[1]] %*% diag(x)
return(B)
}
test2 <- sda_fun(x1, x2, emission_calculator, type = "LMDI1")
x2$Y
x1$Y <- matrix(x1$Y, ncol = 1, nrow = 4)
x2$Y <- matrix(x2$Y, ncol = 1, nrow = 4)
x2$Y
test2 <- sda_fun(x1, x2, emission_calculator, type = "LMDI1")
test2
lapply(test2, sum) %>% unlist %>% sum

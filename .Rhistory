temp0 <- create_named_list(names(year0))
temp1 <- create_named_list(names(year0))
for(i in 1:n) {
# all components on the left hand side from year 0, right: year 1
temp0[1:i] <- year0[1:i]
temp0[i:n] <- year1[i:n]
temp0[[i]] <- delta[[i]]
# the other way round
temp1[1:i] <- year1[1:i]
temp1[i:n] <- year0[i:n]
temp1[[i]] <- delta[[i]]
# take mean of the two
decomp[[i]] <- 0.5 * (fun(temp0) + fun(temp1))
}
} else if(type == "LMDI1") {
# indices
n_em <- dim(year0[[1]])[1]
n_ix <- dim(year0[[2]])[1]
n_iy <- dim(year0[[2]])[2]
n_fd <- dim(year0[[4]])[2]
vars <- expand.grid("n_em" = 1:n_em,
"n_ix" = 1:n_ix,
"n_iy" = 1:n_iy,
"n_fd" = 1:n_fd)
if(version == "forloop") {
for(i in 1:n) {
#mat <- matrix(ncol = n_industriesy, nrow = n_industriesx)
mat <- array(dim = c(n_ix, n_iy, n_em, n_fd))
for(m in 1:n_ix) {
for(n in 1:n_iy) {
for(o in 1:n_em) {
for(p in 1:n_fd) {
if(i == 1) logx <- log(year1[[1]][o,n] / year0[[1]][o,n]) # S
if(i == 2) logx <- log(year1[[2]][m,n] / year0[[2]][m,n]) # L
if(i == 3) logx <- log(year1[[3]] / year0[[3]]) # f
if(i == 4) logx <- log(year1[[4]][m,p] / year0[[4]][m,p]) # B
if(i == 5) logx <- log(year1[[5]][p] / year0[[5]][p]) # d
mat[m,n,o,p] <- log_mean(x = year1[[1]][o,n] * year1[[2]][m,n]
* year1[[3]] * year1[[4]][m,p]
* year1[[5]][p],
y = year0[[1]][o,n] * year0[[2]][m,n] * year0[[3]]
* year1[[4]][m,p]
* year1[[5]][p]) *
logx
}
}
}
}
decomp[[i]] <- mat
}
}
else if(version == "faster") {
for(i in 1:n) {
#mat <- matrix(ncol = n_industriesy, nrow = n_industriesx)
mat <- array(dim = c(n_ix, n_iy, n_em, n_fd))
for(j in 1:nrow(vars)) {
m <- vars[j, "n_ix"]
n <- vars[j, "n_iy"]
o <- vars[j, "n_em"]
p <- vars[j, "n_fd"]
if(i == 1) logx <- log(year1[[1]][o,n] / year0[[1]][o,n]) # S
if(i == 2) logx <- log(year1[[2]][m,n] / year0[[2]][m,n]) # L
if(i == 3) logx <- log(year1[[3]][m,p] / year0[[3]][m,p]) # Y
mat[m,n,o,p] <- log_mean(x = year1[[1]][o,n] * year1[[2]][m,n] * year1[[3]][m,p],
y = year0[[1]][o,n] * year0[[2]][m,n] * year0[[3]][m,p]) *
logx
}
decomp[[i]] <- mat
}
}
}
if(return == "total") {
decomp <- lapply(decomp, function(x) x %>% unlist %>% sum)
}
return(decomp)
}
# _b) Applying function --------------------------------------------------------
x1 <- c(io_table$year0[c("S", "L")], io_table$year0$Y %>% decompose_final_demand)
io_table$year0
io_table$year0$Y
library(data.table)
library(tidyverse)
library(my.utils)
############################################################################## #
##### settings #################################################################
############################################################################## #
path2temp_results <- "./temp_results"
############################################################################## #
##### load data #############################################################
############################################################################## #
io_table <- readRDS(file.path(path2temp_results, "IO_example.RData"))
io_table
# add second column to final demand
io_table$year0$Y <- matrix(c(io_table$year0$Y, 4,7,4,2), ncol = 2, nrow = 4)
io_table$year1$Y <- matrix(c(io_table$year1$Y, 6,7,5,4), ncol = 2, nrow = 4)
io_table$year1$Y
# _a) Functions -----------------------------------------------------------------
sda_fun <- function(year0, year1, fun,
type = "AMDI",
return = c("detailed", "total"),
version = "forloop") {
if(length(year0) != length(year1)) stop("Both lists need to be of same legnth")
if(!all.equal(names(year0), names(year1))) stop("both lists need same elements in same order")
n <- length(year0)
decomp <- create_named_list(names(year0))
if(type == "AMDI") {
# calculate difference for each argument between year 0 and year 1
delta <- lapply(1:n, function(x) {
return(year1[[x]] - year0[[x]])
})
temp0 <- create_named_list(names(year0))
temp1 <- create_named_list(names(year0))
for(i in 1:n) {
# all components on the left hand side from year 0, right: year 1
temp0[1:i] <- year0[1:i]
temp0[i:n] <- year1[i:n]
temp0[[i]] <- delta[[i]]
# the other way round
temp1[1:i] <- year1[1:i]
temp1[i:n] <- year0[i:n]
temp1[[i]] <- delta[[i]]
# take mean of the two
decomp[[i]] <- 0.5 * (fun(temp0) + fun(temp1))
}
} else if(type == "LMDI1") {
# indices
n_em <- dim(year0[[1]])[1]
n_ix <- dim(year0[[2]])[1]
n_iy <- dim(year0[[2]])[2]
n_fd <- dim(year0[[4]])[2]
vars <- expand.grid("n_em" = 1:n_em,
"n_ix" = 1:n_ix,
"n_iy" = 1:n_iy,
"n_fd" = 1:n_fd)
if(version == "forloop") {
for(i in 1:n) {
#mat <- matrix(ncol = n_industriesy, nrow = n_industriesx)
mat <- array(dim = c(n_ix, n_iy, n_em, n_fd))
for(m in 1:n_ix) {
for(n in 1:n_iy) {
for(o in 1:n_em) {
for(p in 1:n_fd) {
if(i == 1) logx <- log(year1[[1]][o,n] / year0[[1]][o,n]) # S
if(i == 2) logx <- log(year1[[2]][m,n] / year0[[2]][m,n]) # L
if(i == 3) logx <- log(year1[[3]] / year0[[3]]) # f
if(i == 4) logx <- log(year1[[4]][m,p] / year0[[4]][m,p]) # B
if(i == 5) logx <- log(year1[[5]][p] / year0[[5]][p]) # d
mat[m,n,o,p] <- log_mean(x = year1[[1]][o,n] * year1[[2]][m,n]
* year1[[3]] * year1[[4]][m,p]
* year1[[5]][p],
y = year0[[1]][o,n] * year0[[2]][m,n] * year0[[3]]
* year1[[4]][m,p]
* year1[[5]][p]) *
logx
}
}
}
}
decomp[[i]] <- mat
}
}
else if(version == "faster") {
for(i in 1:n) {
#mat <- matrix(ncol = n_industriesy, nrow = n_industriesx)
mat <- array(dim = c(n_ix, n_iy, n_em, n_fd))
for(j in 1:nrow(vars)) {
m <- vars[j, "n_ix"]
n <- vars[j, "n_iy"]
o <- vars[j, "n_em"]
p <- vars[j, "n_fd"]
if(i == 1) logx <- log(year1[[1]][o,n] / year0[[1]][o,n]) # S
if(i == 2) logx <- log(year1[[2]][m,n] / year0[[2]][m,n]) # L
if(i == 3) logx <- log(year1[[3]][m,p] / year0[[3]][m,p]) # Y
mat[m,n,o,p] <- log_mean(x = year1[[1]][o,n] * year1[[2]][m,n] * year1[[3]][m,p],
y = year0[[1]][o,n] * year0[[2]][m,n] * year0[[3]][m,p]) *
logx
}
decomp[[i]] <- mat
}
}
}
if(return == "total") {
decomp <- lapply(decomp, function(x) x %>% unlist %>% sum)
}
return(decomp)
}
x1 <- c(io_table$year0[c("S", "L")], io_table$year0$Y %>% decompose_final_demand)
decompose_final_demand <- function(FD_matrix) {
f_vec <- apply(FD_matrix, 1, sum) # FD by industry
y_vec <- apply(FD_matrix, 2, sum) # FD by category
f_tot <- sum(f_vec) # Total FD
d_vec <- y_vec / f_tot # proportion of each category
B_mat <- F_mat %*% diag(1 / y_vec)
return(list("total" = f_tot,
"B_mat" = B_mat,
"d_vec" = d_vec))
}
x1 <- c(io_table$year0[c("S", "L")], io_table$year0$Y %>% decompose_final_demand)
decompose_final_demand
decompose_final_demand <- function(FD_matrix) {
f_vec <- apply(FD_matrix, 1, sum) # FD by industry
y_vec <- apply(FD_matrix, 2, sum) # FD by category
f_tot <- sum(f_vec) # Total FD
d_vec <- y_vec / f_tot # proportion of each category
B_mat <- FD_matrix %*% diag(1 / y_vec)
return(list("total" = f_tot,
"B_mat" = B_mat,
"d_vec" = d_vec))
}
x1 <- c(io_table$year0[c("S", "L")], io_table$year0$Y %>% decompose_final_demand)
x1
x2 <- c(io_table$year1[c("S", "L")], io_table$year1$Y %>% decompose_final_demand)
result_simple <- sda_fun(x1, x2, fun = emission_calculator2, return = "total")
result <- sda_fun(x1, x2, type = "LMDI1", return = "total")
# _a) functions ----------------------------------------------------------------
log_mean <- function(x, y) {
return((x - y) / (log(x) - log(y)))
}
emission_calculator <- function(list, return = c("total", "detailed")) {
if(is.matrix(list[[3]])) list[[3]] <- apply(list[[3]], 1, sum) %>% as.numeric
x <- as.numeric(list[[2]] %*% list[[3]])
if("total" %in% return) B <- list[[1]] %*% x
else if(return == "detailed") B <- list[[1]] %*% diag(x)
return(B)
}
emission_calculator2 <- function(list, return = c("total", "detailed")) {
Y <- list[[3]] * (list[[4]] %*% list[[5]])
B <- emission_calculator(list = c(list[[1]], list[[2]], Y))
return(B)
}
sda_fun <- function(year0, year1, fun,
type = "AMDI",
return = c("total", "detailed"),
version = "forloop") {
#if(type != "polar_average") stop("Only method 'polar average' implemented so far")
if(length(year0) != length(year1)) stop("Both lists need to be of same legnth")
if(!all.equal(names(year0), names(year1))) stop("both lists need same elements in same order")
n <- length(year0)
# calculate difference for each argument between year 0 and year 1
delta <- lapply(1:n, function(x) {
return(year1[[x]] - year0[[x]])
})
decomp <- create_named_list(names(year0))
if(type == "AMDI") {
temp0 <- create_named_list(names(year0))
temp1 <- create_named_list(names(year0))
for(i in 1:n) {
# all components on the left hand side from year 0, right: year 1
temp0[1:i] <- year0[1:i]
temp0[i:n] <- year1[i:n]
temp0[[i]] <- delta[[i]]
# the other way round
temp1[1:i] <- year1[1:i]
temp1[i:n] <- year0[i:n]
temp1[[i]] <- delta[[i]]
# take mean of the two
decomp[[i]] <- 0.5 * (fun(temp0) + fun(temp1))
}
} else if(type == "LMDI1") {
# indices
n_em <- dim(year0[[1]])[1]
n_ix <- dim(year0[[2]])[1]
n_iy <- dim(year0[[2]])[2]
n_fd <- dim(year0[[3]])[2]
vars <- expand.grid("n_em" = 1:n_em,
"n_ix" = 1:n_ix,
"n_iy" = 1:n_iy,
"n_fd" = 1:n_fd)
if(version == "forloop") {
for(i in 1:n) {
#mat <- matrix(ncol = n_industriesy, nrow = n_industriesx)
mat <- array(dim = c(n_ix, n_iy, n_em, n_fd))
for(m in 1:n_ix) {
for(n in 1:n_iy) {
for(o in 1:n_em) {
for(p in 1:n_fd) {
if(i == 1) logx <- log(year1[[1]][o,n] / year0[[1]][o,n]) # S
if(i == 2) logx <- log(year1[[2]][m,n] / year0[[2]][m,n]) # L
if(i == 3) logx <- log(year1[[3]][m,p] / year0[[3]][m,p]) # Y
mat[m,n,o,p] <- log_mean(x = year1[[1]][o,n] * year1[[2]][m,n] * year1[[3]][m,p],
y = year0[[1]][o,n] * year0[[2]][m,n] * year0[[3]][m,p]) *
logx
# mat[m,n] <- log_mean(x = year1[[1]][o,n] * year1[[2]][m,n] * year1[[3]][m,p],
#                          y = year0[[1]][o,n] * year0[[2]][m,n] * year0[[3]][m,p]) *
#   logx
}
}
}
}
decomp[[i]] <- mat
}
}
else if(version == "faster") {
for(i in 1:n) {
#mat <- matrix(ncol = n_industriesy, nrow = n_industriesx)
mat <- array(dim = c(n_ix, n_iy, n_em, n_fd))
for(j in 1:nrow(vars)) {
m <- vars[j, "n_ix"]
n <- vars[j, "n_iy"]
o <- vars[j, "n_em"]
p <- vars[j, "n_fd"]
if(i == 1) logx <- log(year1[[1]][o,n] / year0[[1]][o,n]) # S
if(i == 2) logx <- log(year1[[2]][m,n] / year0[[2]][m,n]) # L
if(i == 3) logx <- log(year1[[3]][m,p] / year0[[3]][m,p]) # Y
mat[m,n,o,p] <- log_mean(x = year1[[1]][o,n] * year1[[2]][m,n] * year1[[3]][m,p],
y = year0[[1]][o,n] * year0[[2]][m,n] * year0[[3]][m,p]) *
logx
}
decomp[[i]] <- mat
}
}
}
if("total" %in% return) {
decomp <- lapply(decomp, function(x) x %>% unlist %>% sum)
}
return(decomp)
}
result <- sda_fun(x1, x2, type = "LMDI1", return = "total")
result_detailed <- sda_fun(x1, x2, type = "LMDI1", return = "detailed")
result_simple
x1
io_table
io_table$year0
io_table$year0$L
L_el <- io_table$year0$L
L_ind <- io_table$year0$L
L_ind[3,] <- 0
L_ind
L_el <- io_table$year0$L - L_ind
L_el
S <- io_table$year0$S
Y <- io_table$year0$Y
L <- io_table$year0$L
L_ind <- L
L_ind[3,] <- 0
L_el <- io_table$year0$L - L_ind
L_el
emission_calculator(list(S, L, Y))
emission_calculator(list(S, L_ind, Y))
emission_calculator(list(S, L_el, Y))
S_ind <- emission_calculator(list(S, L_ind, Y))
S_el <- emission_calculator(list(S, L_el, Y))
S_el
S_ind + S_el
emission_calculator(list(S, L, Y))
L
sda_fun <- function(year0, year1, fun,
type = "AMDI",
return = c("total", "detailed"),
version = "forloop") {
#if(type != "polar_average") stop("Only method 'polar average' implemented so far")
if(length(year0) != length(year1)) stop("Both lists need to be of same legnth")
if(!all.equal(names(year0), names(year1))) stop("both lists need same elements in same order")
n <- length(year0)
# calculate difference for each argument between year 0 and year 1
delta <- lapply(1:n, function(x) {
return(year1[[x]] - year0[[x]])
})
decomp <- create_named_list(names(year0))
if(type == "AMDI") {
temp0 <- create_named_list(names(year0))
temp1 <- create_named_list(names(year0))
for(i in 1:n) {
# all components on the left hand side from year 0, right: year 1
temp0[1:i] <- year0[1:i]
temp0[i:n] <- year1[i:n]
temp0[[i]] <- delta[[i]]
# the other way round
temp1[1:i] <- year1[1:i]
temp1[i:n] <- year0[i:n]
temp1[[i]] <- delta[[i]]
# take mean of the two
decomp[[i]] <- 0.5 * (fun(temp0) + fun(temp1))
}
} else if(type == "LMDI1") {
# indices
n_em <- dim(year0[[1]])[1]
n_ix <- dim(year0[[2]])[1]
n_iy <- dim(year0[[2]])[2]
n_fd <- dim(year0[[3]])[2]
vars <- expand.grid("n_em" = 1:n_em,
"n_ix" = 1:n_ix,
"n_iy" = 1:n_iy,
"n_fd" = 1:n_fd)
if(version == "forloop") {
for(i in 1:n) {
#mat <- matrix(ncol = n_industriesy, nrow = n_industriesx)
mat <- array(dim = c(n_ix, n_iy, n_em, n_fd))
for(m in 1:n_ix) {
for(n in 1:n_iy) {
for(o in 1:n_em) {
for(p in 1:n_fd) {
if(i == 1) logx <- log(year1[[1]][o,n] / year0[[1]][o,n]) # S
if(i == 2) logx <- log(year1[[2]][m,n] / year0[[2]][m,n]) # L
if(i == 3) logx <- log(year1[[3]][m,p] / year0[[3]][m,p]) # Y
mat[m,n,o,p] <- log_mean(x = year1[[1]][o,n] * year1[[2]][m,n] * year1[[3]][m,p],
y = year0[[1]][o,n] * year0[[2]][m,n] * year0[[3]][m,p]) *
logx
# mat[m,n] <- log_mean(x = year1[[1]][o,n] * year1[[2]][m,n] * year1[[3]][m,p],
#                          y = year0[[1]][o,n] * year0[[2]][m,n] * year0[[3]][m,p]) *
#   logx
}
}
}
}
decomp[[i]] <- mat
}
}
else if(version == "faster") {
for(i in 1:n) {
#mat <- matrix(ncol = n_industriesy, nrow = n_industriesx)
mat <- array(dim = c(n_ix, n_iy, n_em, n_fd))
for(j in 1:nrow(vars)) {
m <- vars[j, "n_ix"]
n <- vars[j, "n_iy"]
o <- vars[j, "n_em"]
p <- vars[j, "n_fd"]
if(i == 1) logx <- log(year1[[1]][o,n] / year0[[1]][o,n]) # S
if(i == 2) logx <- log(year1[[2]][m,n] / year0[[2]][m,n]) # L
if(i == 3) logx <- log(year1[[3]][m,p] / year0[[3]][m,p]) # Y
mat[m,n,o,p] <- log_mean(x = year1[[1]][o,n] * year1[[2]][m,n] * year1[[3]][m,p],
y = year0[[1]][o,n] * year0[[2]][m,n] * year0[[3]][m,p]) *
logx
}
decomp[[i]] <- mat
}
}
}
if("total" %in% return) {
decomp <- lapply(decomp, function(x) x %>% unlist %>% sum)
}
return(decomp)
}
x0 <- list(S, L, Y)
x1 <- io_table$year1[c("S", "L", "Y")]
x1
sda_fun
sda_fun(x0, x1, type = "LMDI1")
x0 <- list("S" = S,"L" = L,"Y" = Y)
x1 <- io_table$year1[c("S", "L", "Y")]
sda_fun(x0, x1, type = "LMDI1")
sda_fun(x0, x1, type = "LMDI1", "detailed")
sda_fun(x0, x1, type = "LMDI1", return = "detail")
A <- io_table$year0$A
A
A %*% A
A %*% A %>%
.[3,]
y ~ a + b
y
form <- y ~ a + b
form
f <- y ~ a + b
f[[1]]
f[[2]]
f[[3]]
f[[4]]
f[[3]]
f[[3]][[1]]
f[[3]][[2]]
f[[3]][[2]] %>% typeof
f[[3]][[2]] %>% class
terms(f)
f
# apply function --------------------------------------------------------------
a <- 3
b <- 5
f <- y ~ a + b
model.frame(f, data = data.frame(a = a, b = b))
model.frame(f, data = data.frame(y = NA, a = a, b = b))
x1
dims <- list("S" = c("o", "m"),
"L" = c("n", "m"),
"Y" = c("n", "p"))
dims
install.packages("Rfast")
update.packages(ask = FALSE)
update.packages(ask = FALSE)
update.packages(ask = FALSE)
install.packages("rlang")
install.packages("yaml")
install.packages("tsibble")
library(Rfast)
install.packages("Rfast")
library(Rfast)
install.packages("RcppZiggurat")
install.packages("RcppGSL")
install.packages("GSL")
install.packages("RcppGSL")
install.packages("Rfast")
library(Rfast)
system.time(Rfast::mat.mult(A, B))
A <- matrix(rnorm(8000*8000), 8000, 8000)
B <- matrix(rnorm(8000*8000), 8000, 8000)
system.time(Rfast::mat.mult(A, B))
system.time(A %*% B)
system.time(C <- A %*% B)
system.time(C2 <- Rfast::mat.mult(A, B))
Rfast::all_equals(C, C2)
C[1:10, 1:10]
C2[1:10, 1:10]
dif <- C - C2
summary(dif)
library(data.table)
library(tidyverse)
installed.packages()
test <- installed.packages()
mode(test)
test
dim(test)
str(test)
test[1]

L.max = 4, tol = 1, tree = test_tree)
construct_tree <- function(S, A, y, F_total, L.max, tol, tree) {
if(isNullChild(tree)) {
cat("is null child \n")
return(NULL)
}
#L <- lenght(tree$.path)
if(length(tree$.path) == L.max) {
cat("L.max reached \n")
# construct the final node
contributionNode(tree, S, A, y)
for(i in 1:length(y)) {
addNullChild(tree)
} # i
} else {
# add a new sub-tree
contributionNode(tree, S, A, y)
for(i in 1:length(y)) {
Z <- c(tree$.path, i)
cat(Z, "\t")
subtree <- Node(path = Z)
print(subtree)
cat(contributionSubtree(tree = subtree, S, A, y, F_total), "")
if(contributionSubtree(tree = subtree, S, A, y, F_total) < tol) {
# sub-tree is negligible
addNullChild(subtree)
addChild(tree, subtree)
} else {
# recursively build a new sub-tree
addChild(tree, construct_tree(S = S, A = A, y = y,
F_total = F_total, L.max = L.max, tol = tol,
tree = subtree))
}
}
}
return(tree)
}
test_tree <- Node(path = 1)
test <- construct_tree(S = S, A = A, y = Y, F_total = F_total,
L.max = 4, tol = 1, tree = test_tree)
test_tree <- Node(path = 1)
test_tree$.path
contributionSubtree(tree = test_tree, S, A, y, F_total)
this <- test_node
Z <- this$.path
Z
test_node
this <- test_tree
this
Z <- this$.path
Z
len <- length(Z)
len
node.z <- y[Z[1]]
y <- Y
node.z <- y[Z[1]]
node.z
Z[1]
y
for(i in 2:len) {
node.z <- node.z * A[Z[i], Z[i-1]]
}
node.z
F_total[Z[len]]
F_total[Z[len]] * node.z
this <- test_tree
Z <- this$.path
len <- length(Z)
node.z <- y[Z[1]]
for(i in 2:len) {
node.z <- node.z * A[Z[i], Z[i-1]]
}
#y.z <- vector("numeric", length = length(y))
#y.z[Z[len]] <- node.z
return(F_total[Z[len]] * node.z)
F_total[Z[len]] * node.z
node.z
this <- test_tree
this
Z <- this$.path
Z
len <- length(Z)
len
node.z <- y[Z[1]]
len
for(i in 2:len) {
node.z <- node.z * A[Z[i], Z[i-1]]
}
node.z
setMethodS3("contributionSubtree", "Node", function(this, S, A, y, F_total) {
this <- test_tree
Z <- this$.path
len <- length(Z)
node.z <- y[Z[1]]
if(len > 1) {
for(i in 2:len) {
node.z <- node.z * A[Z[i], Z[i-1]]
}
}
#y.z <- vector("numeric", length = length(y))
#y.z[Z[len]] <- node.z
return(F_total[Z[len]] * node.z)
})
contributionSubtree(test_node, S, A, Y, F_total)
test_node
contributionSubtree(tree = test_tree, S, A, y, F_total)
rm(this)
setMethodS3("contributionSubtree", "Node", function(this, S, A, y, F_total) {
Z <- this$.path
len <- length(Z)
node.z <- y[Z[1]]
if(len > 1) {
for(i in 2:len) {
node.z <- node.z * A[Z[i], Z[i-1]]
}
}
#y.z <- vector("numeric", length = length(y))
#y.z[Z[len]] <- node.z
return(F_total[Z[len]] * node.z)
})
contributionSubtree(test_node, S, A, Y, F_total)
contribution_subtree(S, A, Y, F_total, c(1,2,3))
test_tree
contributionSubtree(tree = test_tree, S, A, y, F_total)
test_tree
test_tree$.path
test_tree$.path %>% length
F_total
Y
A
S
test_node
contributionSubtree(test_node, S, A, Y, F_total)
contributionSubtree(tree = test_tree, S, A, y, F_total)
contributionSubtree(test_tree, S, A, y, F_total)
F_total %>% sum
F_total
F_total[,1] * Y[1,]
construct_tree <- function(S, A, y, F_total, L.max, tol, tree) {
if(isNullChild(tree)) {
cat("is null child \n")
return(NULL)
}
#L <- lenght(tree$.path)
if(length(tree$.path) == L.max) {
cat("L.max reached \n")
# construct the final node
contributionNode(tree, S, A, y)
for(i in 1:length(y)) {
addNullChild(tree)
} # i
} else {
# add a new sub-tree
contributionNode(tree, S, A, y)
for(i in 1:length(y)) {
Z <- c(tree$.path, i)
cat(Z, "\t")
subtree <- Node(path = Z)
print(subtree)
cat(contributionSubtree(subtree, S, A, y, F_total), "")
if(contributionSubtree(subtree, S, A, y, F_total) < tol) {
# sub-tree is negligible
addNullChild(subtree)
addChild(tree, subtree)
} else {
# recursively build a new sub-tree
addChild(tree, construct_tree(S = S, A = A, y = y,
F_total = F_total, L.max = L.max, tol = tol,
tree = subtree))
}
}
}
return(tree)
}
test_tree <- Node(path = 0)
test_tree$.path
test <- construct_tree(S = S, A = A, y = Y, F_total = F_total,
L.max = 4, tol = 1, tree = test_tree)
test_tree <- Node(path = 0)
contributionSubtree(test_node, S, A, Y, F_total)
contributionSubtree(test_tree, S, A, Y, F_total)
construct_tree <- function(S, A, y, F_total, L.max, tol, tree) {
if(isNullChild(tree)) {
cat("is null child \n")
return(NULL)
}
#L <- lenght(tree$.path)
if(length(tree$.path) == L.max) {
cat("L.max reached \n")
# construct the final node
contributionNode(tree, S, A, y)
for(i in 1:length(y)) {
addNullChild(tree)
} # i
} else {
# add a new sub-tree
contributionNode(tree, S, A, y)
for(i in 1:length(y)) {
Z <- c(tree$.path, i)
cat(Z, "\t")
subtree <- Node(path = Z)
#print(subtree)
cat(contributionSubtree(subtree, S, A, y, F_total), "")
if(contributionSubtree(subtree, S, A, y, F_total) < tol) {
# sub-tree is negligible
addNullChild(subtree)
addChild(tree, subtree)
} else {
# recursively build a new sub-tree
addChild(tree, construct_tree(S = S, A = A, y = y,
F_total = F_total, L.max = L.max, tol = tol,
tree = subtree))
}
}
}
return(tree)
}
test_tree <- Node(path = 0)
test <- construct_tree(S = S, A = A, y = Y, F_total = F_total,
L.max = 4, tol = 1, tree = test_tree)
construct_tree <- function(S, A, y, F_total, L.max, tol, tree) {
if(isNullChild(tree)) {
cat("is null child \n")
return(NULL)
}
#L <- lenght(tree$.path)
if(length(tree$.path) == L.max) {
cat("L.max reached \n")
# construct the final node
contributionNode(tree, S, A, y)
for(i in 1:length(y)) {
addNullChild(tree)
} # i
} else {
# add a new sub-tree
contributionNode(tree, S, A, y)
for(i in 1:length(y)) {
Z <- c(tree$.path, i)
#      cat(Z, "\t")
subtree <- Node(path = Z)
#print(subtree)
cat(contributionSubtree(subtree, S, A, y, F_total), "")
if(contributionSubtree(subtree, S, A, y, F_total) < tol) {
# sub-tree is negligible
addNullChild(subtree)
addChild(tree, subtree)
} else {
# recursively build a new sub-tree
addChild(tree, construct_tree(S = S, A = A, y = y,
F_total = F_total, L.max = L.max, tol = tol,
tree = subtree))
}
}
}
return(tree)
}
test_tree <- Node(path = 0)
test_tree$.path
test <- construct_tree(S = S, A = A, y = Y, F_total = F_total,
L.max = 4, tol = 1, tree = test_tree)
construct_tree <- function(S, A, y, F_total, L.max, tol, tree) {
if(isNullChild(tree)) {
cat("is null child \n")
return(NULL)
}
#L <- lenght(tree$.path)
if(length(tree$.path) == L.max) {
cat("L.max reached \n")
# construct the final node
contributionNode(tree, S, A, y)
for(i in 1:length(y)) {
addNullChild(tree)
} # i
} else {
# add a new sub-tree
contributionNode(tree, S, A, y)
for(i in 1:length(y)) {
Z <- c(tree$.path, i)
#      cat(Z, "\t")
subtree <- Node(path = Z)
#print(subtree)
print(contributionSubtree(subtree, S, A, y, F_total))
if(contributionSubtree(subtree, S, A, y, F_total) < tol) {
# sub-tree is negligible
addNullChild(subtree)
addChild(tree, subtree)
} else {
# recursively build a new sub-tree
addChild(tree, construct_tree(S = S, A = A, y = y,
F_total = F_total, L.max = L.max, tol = tol,
tree = subtree))
}
}
}
return(tree)
}
test_tree <- Node(path = 0)
test_tree$.path
test <- construct_tree(S = S, A = A, y = Y, F_total = F_total,
L.max = 4, tol = 1, tree = test_tree)
test_tree <- Node(path = NULL)
test_tree$.path
test <- construct_tree(S = S, A = A, y = Y, F_total = F_total,
L.max = 4, tol = 1, tree = test_tree)
test$.childs
test$.value
test$.childs[[1]]
test$.childs[[1]]$.value
test$.childs[[1]]$.path
test$.childs[[1]]$childs
test$.childs[[2]]$childs
test$.childs[[3]]$childs
test$.childs[[4]]$childs
test$.childs[[4]]$.childs
test$.childs[[4]]$.childs$.value
construct_tree <- function(S, A, y, F_total, L.max, tol, tree) {
if(isNullChild(tree)) {
cat("is null child \n")
return(NULL)
}
#L <- lenght(tree$.path)
if(length(tree$.path) == L.max) {
cat("L.max reached \n")
# construct the final node
tree$.value <- contributionNode(tree, S, A, y)
for(i in 1:length(y)) {
addNullChild(tree)
} # i
} else {
# add a new sub-tree
tree$.value <- contributionNode(tree, S, A, y)
for(i in 1:length(y)) {
Z <- c(tree$.path, i)
#      cat(Z, "\t")
subtree <- Node(path = Z)
#print(subtree)
print(contributionSubtree(subtree, S, A, y, F_total))
if(contributionSubtree(subtree, S, A, y, F_total) < tol) {
# sub-tree is negligible
addNullChild(subtree)
addChild(tree, subtree)
} else {
# recursively build a new sub-tree
addChild(tree, construct_tree(S = S, A = A, y = y,
F_total = F_total, L.max = L.max, tol = tol,
tree = subtree))
}
}
}
return(tree)
}
test_tree <- Node(path = NULL)
test_tree$.path
test <- construct_tree(S = S, A = A, y = Y, F_total = F_total,
L.max = 4, tol = 1, tree = test_tree)
test$.childs[[4]]$.childs$.value
test$.value
test$.childs[[1]]
test$.childs[[1]]$.value
test_node <- Node()
test_node$.path <- c(1,2,3)
contributionNode(test_node, S, A, Y)
test_node$.value <- contributionNode(test_node, S, A, Y)
test_node$.value
construct_tree <- function(S, A, y, F_total, L.max, tol, tree) {
if(isNullChild(tree)) {
cat("is null child \n")
return(NULL)
}
#L <- lenght(tree$.path)
if(length(tree$.path) == L.max) {
cat("L.max reached \n")
# construct the final node
tree$.value <- contributionNode(tree, S, A, y)
for(i in 1:length(y)) {
addNullChild(tree)
} # i
} else {
# add a new sub-tree
tree$.value <- contributionNode(tree, S, A, y)
for(i in 1:length(y)) {
Z <- c(tree$.path, i)
#      cat(Z, "\t")
subtree <- Node(path = Z)
#print(subtree)
print(contributionSubtree(subtree, S, A, y, F_total))
if(contributionSubtree(subtree, S, A, y, F_total) < tol) {
# sub-tree is negligible
subtree$.value <- contributionNode(subtree, S, A, y)
addNullChild(subtree)
addChild(tree, subtree)
} else {
# recursively build a new sub-tree
addChild(tree, construct_tree(S = S, A = A, y = y,
F_total = F_total, L.max = L.max, tol = tol,
tree = subtree))
}
}
}
return(tree)
}
test_tree <- Node(path = NULL)
test_tree$.path
test <- construct_tree(S = S, A = A, y = Y, F_total = F_total,
L.max = 4, tol = 1, tree = test_tree)
test$.childs[[1]]$.value
test$.childs
test$.childs[[1]]$.path
test$.childs[[1]]$.childs[[1]]$.path
test$.childs[[1]]$.childs[[4]]$.path
test$.childs[[1]]$.childs[[4]]$.value
test$.childs[[1]]$.childs[[2]]$.value
test$.childs[[1]]$.value
setMethodS3("contributionNode", "Node", function(this, S, A, y) {
len <- length(this$.path)
y <- as.vector(y)
node.z <- y[this$.path[1]]
if(len > 1) {
for(i in 2:len) {
node.z <- node.z * A[this$.path[i], this$.path[i-1]]
}
}
return(S[this$.path[len]] * node.z)
})
test_node <- Node()
test_node$.path <- c(1)
contributionNode(test_node, S, A, Y)
test_node$.path <- c(1,2,3)
contributionNode(test_node, S, A, Y)
construct_tree <- function(S, A, y, F_total, L.max, tol, tree) {
if(isNullChild(tree)) {
cat("is null child \n")
return(NULL)
}
#L <- lenght(tree$.path)
if(length(tree$.path) == L.max) {
cat("L.max reached \n")
# construct the final node
tree$.value <- contributionNode(tree, S, A, y)
for(i in 1:length(y)) {
addNullChild(tree)
} # i
} else {
# add a new sub-tree
tree$.value <- contributionNode(tree, S, A, y)
for(i in 1:length(y)) {
Z <- c(tree$.path, i)
#      cat(Z, "\t")
subtree <- Node(path = Z)
#print(subtree)
print(contributionSubtree(subtree, S, A, y, F_total))
if(contributionSubtree(subtree, S, A, y, F_total) < tol) {
# sub-tree is negligible
subtree$.value <- contributionNode(subtree, S, A, y)
addNullChild(subtree)
addChild(tree, subtree)
} else {
# recursively build a new sub-tree
addChild(tree, construct_tree(S = S, A = A, y = y,
F_total = F_total, L.max = L.max, tol = tol,
tree = subtree))
}
}
}
return(tree)
}
test_tree <- Node(path = NULL)
test_tree$.path
test <- construct_tree(S = S, A = A, y = Y, F_total = F_total,
L.max = 4, tol = 1, tree = test_tree)
test$.childs[[1]]$.value
test$.childs[[2]]$.value
F_total
S * Y
S %*% Y
S %*% diag(Y)
S
diag(Y)
Y
S %*% diag(Y %>% as.numeric)
test$.childs[[2]]$.value
test$.childs[[1]]$.value
test$.childs[[4]]$.value
S %*% diag(Y %>% as.numeric)
S %*% diag(Y %>% as.numeric) %>% sum
test_tree <- Node(path = NULL)
test_tree$.path
test <- construct_tree(S = S, A = A, y = Y, F_total = F_total,
L.max = 4, tol = 50, tree = test_tree)
test$.childs
test$.childs[[4]]$.value
test$.childs[[3]]$.value
test$.childs[[3]]$.childs
test$.childs[[3]]$.childs
test$.childs[[3]]$.childs[[1]]$.childs
test$.childs[[3]]$.childs[[1]]$.childs[[1]]$.childs
setMethodS3("setValue", "Node", function(this, S, A, y) {
len <- length(this$.path)
y <- as.vector(y)
node.z <- y[this$.path[1]]
if(len > 1) {
for(i in 2:len) {
node.z <- node.z * A[this$.path[i], this$.path[i-1]]
}
}
test$.value <- S[this$.path[len]] * node.z
#return(S[this$.path[len]] * node.z)
})
test_node <- Node()
test_node$.path <- c(1,2,3)
setValue(test_node, S, A, Y)
test_node$.value

IO_calculator <- function(S, L, Y, detailed = TRUE) {
# calculate emissions
x <- as.numeric(L %*% Y)
if(detailed)
B <- S %*% diag(x)
else B <- S %*% x
return(B)
}
IO_calculator(S, L, Y, F)
#FD_matrix <- matrix(runif(12), 4,3)
decompose_final_demand <- function(FD_matrix) {
# TODO: all components should be of type matrix
f_vec <- apply(FD_matrix, 1, sum) # FD by industry
y_vec <- apply(FD_matrix, 2, sum) # FD by category
f_tot <- matrix(sum(f_vec), 1,1) # Total FD
d_vec <- matrix(y_vec / as.numeric(f_tot)) # proportion of each category
B_mat <- FD_matrix %*% diag(1 / y_vec)
# return(list("B_mat" = B_mat,
#             "d_vec" = d_vec,
#            "total" = f_tot))
return(list("B" = B_mat,
"d" = d_vec,
"f" = f_tot))
}
emission_calculator2 <- function(list, return = c("total", "detailed")) {
Y <- list[[3]] * (list[[4]] %*% list[[5]])
B <- emission_calculator(list = c(list[[1]], list[[2]], Y))
return(B)
}
missing(a)
a
b
missing(c(a,b))
IO_calculator <- function(S, L, Y, B, d, f, detailed = TRUE) {
if(!missing(B) & !missing(d) & !missing(f))
Y <- B %*% d * f
x <- as.numeric(L %*% Y)
if(detailed)
B <- S %*% diag(x)
else B <- S %*% x
return(B)
}
IO_calculator(S, L, Y, F)
IO_calculator(S, L, Y, T)
IO_calculator <- function(S, L, Y, B, d, f, detailed = TRUE) {
if(!missing(B) & !missing(d) & !missing(f))
Y <- B %*% d * f
x <- as.numeric(L %*% Y)
if(detailed)
B <- S %*% diag(x)
else B <- S %*% x
return(B)
}
IO_calculator(S, L, Y, detailed = FALSE)
Y
decompose(cbind(Y, c(5,3,1,0)))
cbind(Y, c(5,3,1,0))
decompose_final_demand(cbind(Y, c(5,3,1,0)))
test <- decompose_final_demand(cbind(Y, c(5,3,1,0)))
IO_calculator(S, L, test$B, test$d, test$f, detailed = FALSE)
B <- test$B
d <- test$d
f <- test$f
if(!missing(B) & !missing(d) & !missing(f))
if(!missing(B) & !missing(d) & !missing(f)) Y <- B %*% d * f
if(!missing(B) & !missing(d) & !missing(f)) Y <- B %*% d * f
B %*% d * f
if(!missing(B) & !missing(d) & !missing(f)) Y <- (B %*% d) * as.numeric(f)
L
Y
x <- as.numeric(L %*% Y)
if(detailed)
B <- S %*% diag(x)
IO_calculator <- function(S, L, Y, B, d, f, detailed = TRUE) {
if(!missing(B) & !missing(d) & !missing(f)) Y <- (B %*% d) * as.numeric(f)
x <- as.numeric(L %*% Y)
if(detailed)
B <- S %*% diag(x)
else B <- S %*% x
return(B)
}
IO_calculator(S, L, test$B, test$d, test$f, detailed = FALSE)
L
S
test$f
IO_calculator(S, L, test$B, test$d, as.numeric(test$f), detailed = FALSE)
IO_calculator <- function(S, L, Y, B, d, f, detailed = TRUE) {
if(!missing(B) & !missing(d) & !missing(f)) Y <- (B %*% d) * as.numeric(f)
x <- as.numeric(L %*% Y)
if(detailed) B <- S %*% diag(x)
else B <- S %*% x
return(B)
}
IO_calculator(S, L, test$B, test$d, as.numeric(test$f), detailed = FALSE)
x
S
S %*% diag(x)
S %*% x
Y
IO_calculator <- function(S, L, Y, B, d, f, detailed = TRUE) {
if(missing(Y)) Y <- (B %*% d) * as.numeric(f)
x <- as.numeric(L %*% Y)
if(detailed) B <- S %*% diag(x)
else B <- S %*% x
return(B)
}
IO_calculator(S, L, B = test$B, d = test$d, f = as.numeric(test$f), detailed = FALSE)
IO_calculator(S, L, Y = Y B = test$B, d = test$d, f = as.numeric(test$f), detailed = FALSE)
IO_calculator(S, L, Y = Y, B = test$B, d = test$d, f = as.numeric(test$f), detailed = FALSE)
IO_calculator(S, L, Y = Y, B = test$B, d = test$d, f = as.numeric(test$f), detailed = FALSE)
io_table$year0[c("S", "L", "A")]
IO_calculator(S = io_table$year0$S, L = io_table$year0$L,
Y = io_table$year0$Y, detailed = FALSE)
e0 <- IO_calculator(S = io_table$year0$S, L = io_table$year0$L,
Y = io_table$year0$Y, detailed = FALSE)
e1 <- IO_calculator(S = io_table$year1$S, L = io_table$year1$L,
Y = io_table$year1$Y, detailed = FALSE)
delta_e <- e1 - e0
delta_e
0.01 * delta_e
test <- spd(x1, x2, 4, cut = as.numeric(0.01 * delta_e))
test
as.numeric(0.01 * delta_e)
spd <- function(year0, year1,
n.layers, cut = FALSE) {
# begin test
# year0 <- io_table$year0[c("S", "L", "Y", "A")]
#  year1 <- io_table$year1[c("S", "L", "Y", "A")]
# n.layers <- 3
# end test
if(length(year0) != length(year1)) stop("Both lists need to be of same length")
if(!all.equal(names(year0), names(year1))) stop("both lists need same elements in same order")
n.comp <- length(year0)
decomp <- vector("list", length = n.layers)
# extract all but L and A matrices
x0 <- year0[!(names(year0) %in% c("L", "A"))]
x1 <- year1[!(names(year1) %in% c("L", "A"))]
for(ilayer in 1:n.layers) {
decomp[[ilayer]] <- .SDA.lmdi(x0, x1, aggregate = FALSE)
x0 <- append(x0, list(year0[["A"]]), ilayer)
x1 <- append(x1, list(year1[["A"]]), ilayer)
names(x0)[ilayer + 1] <- paste0("A", ilayer)
names(x1)[ilayer + 1] <- paste0("A", ilayer)
} # ilayer
decomp <- lapply(decomp, function(y) {
lapply(y, function(x) {
res <- as.data.table(x)
if(cut > 0) res <- res[value > cut | value < cut]
return(res)
}) %>% rbindlist(idcol = "differential")
})
return(decomp)
}
test <- spd(x1, x2, 4, cut = as.numeric(0.01 * delta_e))
test
as.numeric(0.01 * delta_e)
spd <- function(year0, year1,
n.layers, cut = NULL) {
# begin test
# year0 <- io_table$year0[c("S", "L", "Y", "A")]
#  year1 <- io_table$year1[c("S", "L", "Y", "A")]
# n.layers <- 3
# end test
if(length(year0) != length(year1)) stop("Both lists need to be of same length")
if(!all.equal(names(year0), names(year1))) stop("both lists need same elements in same order")
n.comp <- length(year0)
decomp <- vector("list", length = n.layers)
# extract all but L and A matrices
x0 <- year0[!(names(year0) %in% c("L", "A"))]
x1 <- year1[!(names(year1) %in% c("L", "A"))]
for(ilayer in 1:n.layers) {
decomp[[ilayer]] <- .SDA.lmdi(x0, x1, aggregate = FALSE)
x0 <- append(x0, list(year0[["A"]]), ilayer)
x1 <- append(x1, list(year1[["A"]]), ilayer)
names(x0)[ilayer + 1] <- paste0("A", ilayer)
names(x1)[ilayer + 1] <- paste0("A", ilayer)
} # ilayer
decomp <- lapply(decomp, function(y) {
lapply(y, function(x) {
res <- as.data.table(x)
if(!is.null(cut)) res <- res[value > cut | value < cut]
return(res)
}) %>% rbindlist(idcol = "differential")
})
return(decomp)
}
test <- spd(x1, x2, 4, cut = as.numeric(0.01 * delta_e))
test
spd <- function(year0, year1,
n.layers, cut = NULL) {
# begin test
# year0 <- io_table$year0[c("S", "L", "Y", "A")]
#  year1 <- io_table$year1[c("S", "L", "Y", "A")]
# n.layers <- 3
# end test
if(length(year0) != length(year1)) stop("Both lists need to be of same length")
if(!all.equal(names(year0), names(year1))) stop("both lists need same elements in same order")
n.comp <- length(year0)
decomp <- vector("list", length = n.layers)
# extract all but L and A matrices
x0 <- year0[!(names(year0) %in% c("L", "A"))]
x1 <- year1[!(names(year1) %in% c("L", "A"))]
for(ilayer in 1:n.layers) {
decomp[[ilayer]] <- .SDA.lmdi(x0, x1, aggregate = FALSE)
x0 <- append(x0, list(year0[["A"]]), ilayer)
x1 <- append(x1, list(year1[["A"]]), ilayer)
names(x0)[ilayer + 1] <- paste0("A", ilayer)
names(x1)[ilayer + 1] <- paste0("A", ilayer)
} # ilayer
decomp <- lapply(decomp, function(y) {
lapply(y, function(x) {
res <- as.data.table(x)
if(!is.null(cut)) res <- res[value > cut | value < cut]
return(res)
}) %>% rbindlist(idcol = "differential")
})
return(decomp)
}
test <- spd(x1, x2, 4, cut = as.numeric(0.01 * delta_e))
test
as.numeric(0.01 * delta_e)
test <- spd(x1, x2, 4, cut = abs(as.numeric(0.01 * delta_e)))
test
spd <- function(year0, year1,
n.layers, cut = NULL) {
# begin test
# year0 <- io_table$year0[c("S", "L", "Y", "A")]
#  year1 <- io_table$year1[c("S", "L", "Y", "A")]
# n.layers <- 3
# end test
if(length(year0) != length(year1)) stop("Both lists need to be of same length")
if(!all.equal(names(year0), names(year1))) stop("both lists need same elements in same order")
n.comp <- length(year0)
decomp <- vector("list", length = n.layers)
# extract all but L and A matrices
x0 <- year0[!(names(year0) %in% c("L", "A"))]
x1 <- year1[!(names(year1) %in% c("L", "A"))]
for(ilayer in 1:n.layers) {
decomp[[ilayer]] <- .SDA.lmdi(x0, x1, aggregate = FALSE)
x0 <- append(x0, list(year0[["A"]]), ilayer)
x1 <- append(x1, list(year1[["A"]]), ilayer)
names(x0)[ilayer + 1] <- paste0("A", ilayer)
names(x1)[ilayer + 1] <- paste0("A", ilayer)
} # ilayer
decomp <- lapply(decomp, function(y) {
lapply(y, function(x) {
res <- as.data.table(x)
if(!is.null(cut)) res <- res[value > cut | value < cut]
return(res)
}) %>% rbindlist(idcol = "differential")
})
return(decomp)
}
test <- spd(x1, x2, 4, cut = abs(as.numeric(0.01 * delta_e)))
test
spd <- function(year0, year1,
n.layers, cut = NULL) {
# begin test
# year0 <- io_table$year0[c("S", "L", "Y", "A")]
#  year1 <- io_table$year1[c("S", "L", "Y", "A")]
# n.layers <- 3
# end test
if(length(year0) != length(year1)) stop("Both lists need to be of same length")
if(!all.equal(names(year0), names(year1))) stop("both lists need same elements in same order")
n.comp <- length(year0)
decomp <- vector("list", length = n.layers)
# extract all but L and A matrices
x0 <- year0[!(names(year0) %in% c("L", "A"))]
x1 <- year1[!(names(year1) %in% c("L", "A"))]
for(ilayer in 1:n.layers) {
decomp[[ilayer]] <- .SDA.lmdi(x0, x1, aggregate = FALSE)
x0 <- append(x0, list(year0[["A"]]), ilayer)
x1 <- append(x1, list(year1[["A"]]), ilayer)
names(x0)[ilayer + 1] <- paste0("A", ilayer)
names(x1)[ilayer + 1] <- paste0("A", ilayer)
} # ilayer
decomp <- lapply(decomp, function(y) {
lapply(y, function(x) {
res <- as.data.table(x)
if(!is.null(cut)) res <- res[abs(value) > cut]
return(res)
}) %>% rbindlist(idcol = "differential")
})
return(decomp)
}
test <- spd(x1, x2, 4, cut = abs(as.numeric(0.01 * delta_e)))
test
test %>% unlist %>% sum
test %>% unlist %>% unlist %>% sum
test %>% unlist
lapply(test,function(x) x$value %>% sum) %>% sum
lapply(test,function(x) x$value %>% sum)
lapply(test,function(x) x$value %>% sum) %>% unlist %>% sum
test <- spd(x1, x2, 4, cut = abs(as.numeric(0.01 * delta_e)))
test2 <- spd(x1, x2, 4)
test2
lapply(test2,function(x) x$value %>% sum) %>% unlist %>% sum
lapply(test,function(x) x$value %>% sum) %>% unlist %>% sum
test <- spd(x1, x2, 4, cut = abs(as.numeric(0.001 * delta_e)))
lapply(test, function(x) x$value %>% sum) %>% unlist %>% sum
test <- spd(x1, x2, 4, cut = abs(as.numeric(0.0001 * delta_e)))
lapply(test, function(x) x$value %>% sum) %>% unlist %>% sum
lapply(test2, function(x) x$value %>% sum) %>% unlist %>% sum
test2
n.comp <- length(year0)
decomp <- vector("list", length = n.layers)
# extract all but L and A matrices
x0 <- year0[!(names(year0) %in% c("L", "A"))]
x1 <- year1[!(names(year1) %in% c("L", "A"))]
for(ilayer in 1:n.layers) {
decomp[[ilayer]] <- .SDA.lmdi(x0, x1, aggregate = FALSE)
x0 <- append(x0, list(year0[["A"]]), ilayer)
x1 <- append(x1, list(year1[["A"]]), ilayer)
names(x0)[ilayer + 1] <- paste0("A", ilayer)
names(x1)[ilayer + 1] <- paste0("A", ilayer)
} # ilayer
object.size(decomp)
decomp <- lapply(decomp, function(y) {
lapply(y, function(x) {
res <- as.data.table(x)
if(!is.null(cut)) res <- res[abs(value) > cut]
return(res)
}) %>% rbindlist(idcol = "differential")
})
decomp
decomp <- lapply(decomp, function(y) {
lapply(y, function(x) {
res <- as.data.table(x)
#if(!is.null(cut)) res <- res[abs(value) > cut]
return(res)
}) %>% rbindlist(idcol = "differential")
})
object.size(decomp)
decomp <- vector("list", length = n.layers)
# extract all but L and A matrices
x0 <- year0[!(names(year0) %in% c("L", "A"))]
x1 <- year1[!(names(year1) %in% c("L", "A"))]
for(ilayer in 1:n.layers) {
decomp[[ilayer]] <- .SDA.lmdi(x0, x1, aggregate = FALSE)
x0 <- append(x0, list(year0[["A"]]), ilayer)
x1 <- append(x1, list(year1[["A"]]), ilayer)
names(x0)[ilayer + 1] <- paste0("A", ilayer)
names(x1)[ilayer + 1] <- paste0("A", ilayer)
} # ilayer
object.size(decomp)
5944/17872
test2
decomp
decomp[[1]]
n.comp <- length(year0)
decomp <- vector("list", length = n.layers)
# extract all but L and A matrices
x0 <- year0[!(names(year0) %in% c("L", "A"))]
x1 <- year1[!(names(year1) %in% c("L", "A"))]
# begin test
# year0 <- io_table$year0[c("S", "L", "Y", "A")]
#  year1 <- io_table$year1[c("S", "L", "Y", "A")]
year0 <- x1
year0
x1 <- c(io_table$year0[c("S", "L", "A")], cbind(io_table$year0$Y, c(5,3,1,0)) %>% decompose_final_demand)
x2 <- c(io_table$year1[c("S", "L", "A")], cbind(io_table$year1$Y, c(6,3,4,2)) %>% decompose_final_demand)
x1
year1 <- x2
# end test
if(length(year0) != length(year1)) stop("Both lists need to be of same length")
if(!all.equal(names(year0), names(year1))) stop("both lists need same elements in same order")
n.comp <- length(year0)
decomp <- vector("list", length = n.layers)
# extract all but L and A matrices
x0 <- year0[!(names(year0) %in% c("L", "A"))]
x1 <- year1[!(names(year1) %in% c("L", "A"))]
x0
x1
x1 <- year1[!(names(year1) %in% c("L", "A"))]
x1
# extract all but L and A matrices
x0 <- year0[!(names(year0) %in% c("L", "A"))]
x0
year0
x1 <- c(io_table$year0[c("S", "L", "A")], cbind(io_table$year0$Y, c(5,3,1,0)) %>% decompose_final_demand)
x2 <- c(io_table$year1[c("S", "L", "A")], cbind(io_table$year1$Y, c(6,3,4,2)) %>% decompose_final_demand)
x2
x1
# begin test
# year0 <- io_table$year0[c("S", "L", "Y", "A")]
#  year1 <- io_table$year1[c("S", "L", "Y", "A")]
year0 <- x1
year1 <- x2
n.comp <- length(year0)
decomp <- vector("list", length = n.layers)
# extract all but L and A matrices
x0 <- year0[!(names(year0) %in% c("L", "A"))]
x0
x1 <- year1[!(names(year1) %in% c("L", "A"))]
x1
for(ilayer in 1:n.layers) {
decomp[[ilayer]] <- .SDA.lmdi(x0, x1, aggregate = FALSE)
x0 <- append(x0, list(year0[["A"]]), ilayer)
x1 <- append(x1, list(year1[["A"]]), ilayer)
names(x0)[ilayer + 1] <- paste0("A", ilayer)
names(x1)[ilayer + 1] <- paste0("A", ilayer)
} # ilayer
decomp[[1]]
decomp[[1,3,2,1,1]]
decomp[1,3,2,1,1]
decomp[[1]][1,3,2,1,1]
decomp[[1]]
decomp[[1]][1,1,1,1,1]
decomp[[1]][1,1,1,1]
decomp[[1]][1,1,1]
decomp[[1]][1,1]
decomp[[1]] %>% dim
decomp[[1]]
decomp[[1]]$B %>% dim
decomp[[1]]$B[1,3,2,1,1]
decomp[[1]]$B[1,3,2,1,1] <- NA
decomp <- lapply(decomp, function(y) {
lapply(y, function(x) {
res <- as.data.table(x)
#if(!is.null(cut)) res <- res[abs(value) > cut]
return(res)
}) %>% rbindlist(idcol = "differential")
})
decomp
decomp[[ilayer]]
decomp <- vector("list", length = n.layers)
# extract all but L and A matrices
x0 <- year0[!(names(year0) %in% c("L", "A"))]
x1 <- year1[!(names(year1) %in% c("L", "A"))]
for(ilayer in 1:n.layers) {
decomp[[ilayer]] <- .SDA.lmdi(x0, x1, aggregate = FALSE)
x0 <- append(x0, list(year0[["A"]]), ilayer)
x1 <- append(x1, list(year1[["A"]]), ilayer)
names(x0)[ilayer + 1] <- paste0("A", ilayer)
names(x1)[ilayer + 1] <- paste0("A", ilayer)
} # ilayer
decomp[[ilayer]]
which(decomp[[ilayer]]$B < 0.01)
decomp[[ilayer]]$B[which(decomp[[ilayer]]$B < 0.01)]
decomp[[ilayer]]$B[which(decomp[[ilayer]]$B < 0.01)] <- NA
decomp[[ilayer]]
decomp[[ilayer]]$B
decomp <- lapply(decomp, function(y) {
lapply(y, function(x) {
res <- as.data.table(x)
#if(!is.null(cut)) res <- res[abs(value) > cut]
return(res)
}) %>% rbindlist(idcol = "differential")
})
decomp
spd <- function(year0, year1,
n.layers, cut = NULL) {
# begin test
# year0 <- io_table$year0[c("S", "L", "Y", "A")]
#  year1 <- io_table$year1[c("S", "L", "Y", "A")]
#year0 <- x1
#year1 <- x2
# n.layers <- 3
# end test
if(length(year0) != length(year1)) stop("Both lists need to be of same length")
if(!all.equal(names(year0), names(year1))) stop("both lists need same elements in same order")
n.comp <- length(year0)
decomp <- vector("list", length = n.layers)
# extract all but L and A matrices
x0 <- year0[!(names(year0) %in% c("L", "A"))]
x1 <- year1[!(names(year1) %in% c("L", "A"))]
for(ilayer in 1:n.layers) {
decomp[[ilayer]] <- .SDA.lmdi(x0, x1, aggregate = FALSE)
# decomp[[ilayer]]$B[which(decomp[[ilayer]]$B < 0.01)] <- NA
x0 <- append(x0, list(year0[["A"]]), ilayer)
x1 <- append(x1, list(year1[["A"]]), ilayer)
names(x0)[ilayer + 1] <- paste0("A", ilayer)
names(x1)[ilayer + 1] <- paste0("A", ilayer)
} # ilayer
#decomp[[1]]$B[1,3,2,1,1] <- NA
decomp <- lapply(decomp, function(y) {
lapply(y, function(x) {
res <- as.data.table(x)
#if(!is.null(cut)) res <- res[abs(value) > cut]
return(res)
}) %>% rbindlist(idcol = "differential")
})
return(decomp)
}
x1 <- c(io_table$year0[c("S", "L", "A")], cbind(io_table$year0$Y, c(5,3,1,0)) %>% decompose_final_demand)
x2 <- c(io_table$year1[c("S", "L", "A")], cbind(io_table$year1$Y, c(6,3,4,2)) %>% decompose_final_demand)
test2 <- spd(x1, x2, 4)
test2
test2 <- spd(x1, x2, 8)
test2
11*4^8*2
10*4^8*2
11*4^8*2
11*7987^8*2
11*7987^4*2
array(NA, dim = c(4,4,4,4))
array(NA, dim = c(4,4,4,4)) %>% object.size
array(runif(4^4), dim = c(4,4,4,4)) %>% object.size
array(runif(4^4), dim = c(4,4,4,4))
array(runif(4^4), dim = c(4,4,4,4)) %>% object.size
array(runif(4^4), dim = c(4,4,4,4))
array(NaN, dim = c(4,4,4,4)) %>% object.size
array(NA, dim = c(4,4,4,4)) %>% object.size
array(0, dim = c(4,4,4,4)) %>% object.size
array(TRUE, dim = c(4,4,4,4)) %>% object.size
test <- array(runif(4^4), dim = c(4,4,4,4))
object.size(test)
test[1,]
test[1,,,]
test[1,,,] <- NA
test
object.size(test)
